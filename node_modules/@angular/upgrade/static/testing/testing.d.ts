/**
 * @license Angular v9.1.9
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

import { Type } from '@angular/core';

declare let angular: {
    bootstrap: (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) => IInjectorService;
    module: (prefix: string, dependencies?: string[]) => IModule;
    element: {
        (e: string | Element | Document | IAugmentedJQuery): IAugmentedJQuery;
        cleanData: (nodes: Node[] | NodeList) => void;
    };
    injector: (modules: Array<string | IInjectable>, strictDi?: boolean) => IInjectorService;
    version: {
        major: number;
    };
    resumeBootstrap: () => void;
    getTestability: (e: Element) => ITestabilityService;
};


/**
 * A helper function to use when unit testing AngularJS services that depend upon downgraded Angular
 * services.
 *
 * This function returns an AngularJS module that is configured to wire up the AngularJS and Angular
 * injectors without the need to actually bootstrap a hybrid application.
 * This makes it simpler and faster to unit test services.
 *
 * Use the returned AngularJS module in a call to
 * [`angular.mocks.module`](https://docs.angularjs.org/api/ngMock/function/angular.mock.module) to
 * include this module in the unit test injector.
 *
 * In the following code snippet, we are configuring the `$injector` with two modules:
 * The AngularJS `ng1AppModule`, which is the AngularJS part of our hybrid application and the
 * `Ng2AppModule`, which is the Angular part.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts"
 * region="angularjs-setup"></code-example>
 *
 * Once this is done we can get hold of services via the AngularJS `$injector` as normal.
 * Services that are (or have dependencies on) a downgraded Angular service, will be instantiated as
 * needed by the Angular root `Injector`.
 *
 * In the following code snippet, `heroesService` is a downgraded Angular service that we are
 * accessing from AngularJS.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts"
 * region="angularjs-spec"></code-example>
 *
 * <div class="alert is-important">
 *
 * This helper is for testing services not components.
 * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or
 * `downgradeModule` for more information.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the
 * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger
 * AngularJS handlers of async events from Angular.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The helper sets up global variables to hold the shared Angular and AngularJS injectors.
 *
 * * Only call this helper once per spec.
 * * Do not use `createAngularJSTestingModule` in the same spec as `createAngularTestingModule`.
 *
 * </div>
 *
 * Here is the example application and its unit tests that use `createAngularTestingModule`
 * and `createAngularJSTestingModule`.
 *
 * <code-tabs>
 *  <code-pane header="module.spec.ts" path="upgrade/static/ts/full/module.spec.ts"></code-pane>
 *  <code-pane header="module.ts" path="upgrade/static/ts/full/module.ts"></code-pane>
 * </code-tabs>
 *
 *
 * @param angularModules a collection of Angular modules to include in the configuration.
 *
 * @publicApi
 */
export declare function createAngularJSTestingModule(angularModules: any[]): string;

/**
 * A helper function to use when unit testing Angular services that depend upon upgraded AngularJS
 * services.
 *
 * This function returns an `NgModule` decorated class that is configured to wire up the Angular
 * and AngularJS injectors without the need to actually bootstrap a hybrid application.
 * This makes it simpler and faster to unit test services.
 *
 * Use the returned class as an "import" when configuring the `TestBed`.
 *
 * In the following code snippet, we are configuring the TestBed with two imports.
 * The `Ng2AppModule` is the Angular part of our hybrid application and the `ng1AppModule` is the
 * AngularJS part.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts" region="angular-setup"></code-example>
 *
 * Once this is done we can get hold of services via the Angular `Injector` as normal.
 * Services that are (or have dependencies on) an upgraded AngularJS service, will be instantiated
 * as needed by the AngularJS `$injector`.
 *
 * In the following code snippet, `HeroesService` is an Angular service that depends upon an
 * AngularJS service, `titleCase`.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts" region="angular-spec"></code-example>
 *
 * <div class="alert is-important">
 *
 * This helper is for testing services not Components.
 * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or
 * `downgradeModule` for more information.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the
 * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger
 * AngularJS handlers of async events from Angular.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The helper sets up global variables to hold the shared Angular and AngularJS injectors.
 *
 * * Only call this helper once per spec.
 * * Do not use `createAngularTestingModule` in the same spec as `createAngularJSTestingModule`.
 *
 * </div>
 *
 * Here is the example application and its unit tests that use `createAngularTestingModule`
 * and `createAngularJSTestingModule`.
 *
 * <code-tabs>
 *  <code-pane header="module.spec.ts" path="upgrade/static/ts/full/module.spec.ts"></code-pane>
 *  <code-pane header="module.ts" path="upgrade/static/ts/full/module.ts"></code-pane>
 * </code-tabs>
 *
 *
 * @param angularJSModules a collection of the names of AngularJS modules to include in the
 * configuration.
 * @param [strictDi] whether the AngularJS injector should have `strictDI` enabled.
 *
 * @publicApi
 */
export declare function createAngularTestingModule(angularJSModules: string[], strictDi?: boolean): Type<any>;

declare type DirectiveRequireProperty = SingleOrListOrMap<string>;

declare type DirectiveTranscludeProperty = boolean | 'element' | {
    [key: string]: string;
};

declare interface IAngularBootstrapConfig {
    strictDi?: boolean;
}

declare interface IAnnotatedFunction extends Function {
    $inject?: Function extends {
        $inject?: string[];
    } ? Ng1Token[] : ReadonlyArray<Ng1Token>;
}

declare type IAugmentedJQuery = Node[] & {
    on?: (name: string, fn: () => void) => void;
    data?: (name: string, value?: any) => any;
    text?: () => string;
    inheritedData?: (name: string, value?: any) => any;
    contents?: () => IAugmentedJQuery;
    parent?: () => IAugmentedJQuery;
    empty?: () => void;
    append?: (content: IAugmentedJQuery | string) => IAugmentedJQuery;
    controller?: (name: string) => any;
    isolateScope?: () => IScope;
    injector?: () => IInjectorService;
    triggerHandler?: (eventTypeOrObject: string | Event, extraParameters?: any[]) => IAugmentedJQuery;
    remove?: () => void;
    removeData?: () => void;
};

declare interface IComponent {
    bindings?: {
        [key: string]: string;
    };
    controller?: string | IInjectable;
    controllerAs?: string;
    require?: DirectiveRequireProperty;
    template?: string | Function;
    templateUrl?: string | Function;
    transclude?: DirectiveTranscludeProperty;
}

declare type IInjectable = (Ng1Token | Function)[] | IAnnotatedFunction;

declare interface IInjectorService {
    get(key: string): any;
    has(key: string): boolean;
}

declare interface IModule {
    name: string;
    requires: (string | IInjectable)[];
    config(fn: IInjectable): IModule;
    directive(selector: string, factory: IInjectable): IModule;
    component(selector: string, component: IComponent): IModule;
    controller(name: string, type: IInjectable): IModule;
    factory(key: Ng1Token, factoryFn: IInjectable): IModule;
    value(key: Ng1Token, value: any): IModule;
    constant(token: Ng1Token, value: any): IModule;
    run(a: IInjectable): IModule;
}

declare interface IRootScopeService {
    $new(isolate?: boolean): IScope;
    $id: string;
    $parent: IScope;
    $root: IScope;
    $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;
    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;
    $destroy(): any;
    $apply(exp?: Ng1Expression): any;
    $digest(): any;
    $evalAsync(exp: Ng1Expression, locals?: any): void;
    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;
    $$childTail: IScope;
    $$childHead: IScope;
    $$nextSibling: IScope;
    [key: string]: any;
}

declare interface IScope extends IRootScopeService {
}

declare interface ITestabilityService {
    findBindings(element: Element, expression: string, opt_exactMatch?: boolean): Element[];
    findModels(element: Element, expression: string, opt_exactMatch?: boolean): Element[];
    getLocation(): string;
    setLocation(url: string): void;
    whenStable(callback: Function): void;
}

declare type Ng1Expression = string | Function;


declare type Ng1Token = string;

declare type SingleOrListOrMap<T> = T | T[] | {
    [key: string]: T;
};

export declare const ɵangular_packages_upgrade_static_testing_testing_a: typeof angular.module;

export declare const ɵangular_packages_upgrade_static_testing_testing_b = "$$angularUpgradeAppType";

export declare const enum ɵangular_packages_upgrade_static_testing_testing_c {
    None = 0,
    Dynamic = 1,
    Static = 2,
    Lite = 3
}

export declare const ɵangular_packages_upgrade_static_testing_testing_d = "$$angularInjector";

export { }

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGluZy5kLnRzIiwic291cmNlcyI6WyJ0ZXN0aW5nLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjkuMS45XG4gKiAoYykgMjAxMC0yMDIwIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmRlY2xhcmUgbGV0IGFuZ3VsYXI6IHtcclxuICAgIGJvb3RzdHJhcDogKGU6IEVsZW1lbnQsIG1vZHVsZXM6IChzdHJpbmcgfCBJSW5qZWN0YWJsZSlbXSwgY29uZmlnPzogSUFuZ3VsYXJCb290c3RyYXBDb25maWcpID0+IElJbmplY3RvclNlcnZpY2U7XHJcbiAgICBtb2R1bGU6IChwcmVmaXg6IHN0cmluZywgZGVwZW5kZW5jaWVzPzogc3RyaW5nW10pID0+IElNb2R1bGU7XHJcbiAgICBlbGVtZW50OiB7XHJcbiAgICAgICAgKGU6IHN0cmluZyB8IEVsZW1lbnQgfCBEb2N1bWVudCB8IElBdWdtZW50ZWRKUXVlcnkpOiBJQXVnbWVudGVkSlF1ZXJ5O1xyXG4gICAgICAgIGNsZWFuRGF0YTogKG5vZGVzOiBOb2RlW10gfCBOb2RlTGlzdCkgPT4gdm9pZDtcclxuICAgIH07XHJcbiAgICBpbmplY3RvcjogKG1vZHVsZXM6IEFycmF5PHN0cmluZyB8IElJbmplY3RhYmxlPiwgc3RyaWN0RGk/OiBib29sZWFuKSA9PiBJSW5qZWN0b3JTZXJ2aWNlO1xyXG4gICAgdmVyc2lvbjoge1xyXG4gICAgICAgIG1ham9yOiBudW1iZXI7XHJcbiAgICB9O1xyXG4gICAgcmVzdW1lQm9vdHN0cmFwOiAoKSA9PiB2b2lkO1xyXG4gICAgZ2V0VGVzdGFiaWxpdHk6IChlOiBFbGVtZW50KSA9PiBJVGVzdGFiaWxpdHlTZXJ2aWNlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byB1c2Ugd2hlbiB1bml0IHRlc3RpbmcgQW5ndWxhckpTIHNlcnZpY2VzIHRoYXQgZGVwZW5kIHVwb24gZG93bmdyYWRlZCBBbmd1bGFyXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gQW5ndWxhckpTIG1vZHVsZSB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gd2lyZSB1cCB0aGUgQW5ndWxhckpTIGFuZCBBbmd1bGFyXHJcbiAqIGluamVjdG9ycyB3aXRob3V0IHRoZSBuZWVkIHRvIGFjdHVhbGx5IGJvb3RzdHJhcCBhIGh5YnJpZCBhcHBsaWNhdGlvbi5cclxuICogVGhpcyBtYWtlcyBpdCBzaW1wbGVyIGFuZCBmYXN0ZXIgdG8gdW5pdCB0ZXN0IHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBVc2UgdGhlIHJldHVybmVkIEFuZ3VsYXJKUyBtb2R1bGUgaW4gYSBjYWxsIHRvXHJcbiAqIFtgYW5ndWxhci5tb2Nrcy5tb2R1bGVgXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdNb2NrL2Z1bmN0aW9uL2FuZ3VsYXIubW9jay5tb2R1bGUpIHRvXHJcbiAqIGluY2x1ZGUgdGhpcyBtb2R1bGUgaW4gdGhlIHVuaXQgdGVzdCBpbmplY3Rvci5cclxuICpcclxuICogSW4gdGhlIGZvbGxvd2luZyBjb2RlIHNuaXBwZXQsIHdlIGFyZSBjb25maWd1cmluZyB0aGUgYCRpbmplY3RvcmAgd2l0aCB0d28gbW9kdWxlczpcclxuICogVGhlIEFuZ3VsYXJKUyBgbmcxQXBwTW9kdWxlYCwgd2hpY2ggaXMgdGhlIEFuZ3VsYXJKUyBwYXJ0IG9mIG91ciBoeWJyaWQgYXBwbGljYXRpb24gYW5kIHRoZVxyXG4gKiBgTmcyQXBwTW9kdWxlYCwgd2hpY2ggaXMgdGhlIEFuZ3VsYXIgcGFydC5cclxuICpcclxuICogPGNvZGUtZXhhbXBsZSBwYXRoPVwidXBncmFkZS9zdGF0aWMvdHMvZnVsbC9tb2R1bGUuc3BlYy50c1wiXHJcbiAqIHJlZ2lvbj1cImFuZ3VsYXJqcy1zZXR1cFwiPjwvY29kZS1leGFtcGxlPlxyXG4gKlxyXG4gKiBPbmNlIHRoaXMgaXMgZG9uZSB3ZSBjYW4gZ2V0IGhvbGQgb2Ygc2VydmljZXMgdmlhIHRoZSBBbmd1bGFySlMgYCRpbmplY3RvcmAgYXMgbm9ybWFsLlxyXG4gKiBTZXJ2aWNlcyB0aGF0IGFyZSAob3IgaGF2ZSBkZXBlbmRlbmNpZXMgb24pIGEgZG93bmdyYWRlZCBBbmd1bGFyIHNlcnZpY2UsIHdpbGwgYmUgaW5zdGFudGlhdGVkIGFzXHJcbiAqIG5lZWRlZCBieSB0aGUgQW5ndWxhciByb290IGBJbmplY3RvcmAuXHJcbiAqXHJcbiAqIEluIHRoZSBmb2xsb3dpbmcgY29kZSBzbmlwcGV0LCBgaGVyb2VzU2VydmljZWAgaXMgYSBkb3duZ3JhZGVkIEFuZ3VsYXIgc2VydmljZSB0aGF0IHdlIGFyZVxyXG4gKiBhY2Nlc3NpbmcgZnJvbSBBbmd1bGFySlMuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnNwZWMudHNcIlxyXG4gKiByZWdpb249XCJhbmd1bGFyanMtc3BlY1wiPjwvY29kZS1leGFtcGxlPlxyXG4gKlxyXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgaXMtaW1wb3J0YW50XCI+XHJcbiAqXHJcbiAqIFRoaXMgaGVscGVyIGlzIGZvciB0ZXN0aW5nIHNlcnZpY2VzIG5vdCBjb21wb25lbnRzLlxyXG4gKiBGb3IgQ29tcG9uZW50IHRlc3RpbmcgeW91IG11c3Qgc3RpbGwgYm9vdHN0cmFwIGEgaHlicmlkIGFwcC4gU2VlIGBVcGdyYWRlTW9kdWxlYCBvclxyXG4gKiBgZG93bmdyYWRlTW9kdWxlYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogPC9kaXY+XHJcbiAqXHJcbiAqIDxkaXYgY2xhc3M9XCJhbGVydCBpcy1pbXBvcnRhbnRcIj5cclxuICpcclxuICogVGhlIHJlc3VsdGluZyBjb25maWd1cmF0aW9uIGRvZXMgbm90IHdpcmUgdXAgQW5ndWxhckpTIGRpZ2VzdHMgdG8gWm9uZSBob29rcy4gSXQgaXMgdGhlXHJcbiAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB0ZXN0IHdyaXRlciB0byBjYWxsIGAkcm9vdFNjb3BlLiRhcHBseWAsIGFzIG5lY2Vzc2FyeSwgdG8gdHJpZ2dlclxyXG4gKiBBbmd1bGFySlMgaGFuZGxlcnMgb2YgYXN5bmMgZXZlbnRzIGZyb20gQW5ndWxhci5cclxuICpcclxuICogPC9kaXY+XHJcbiAqXHJcbiAqIDxkaXYgY2xhc3M9XCJhbGVydCBpcy1pbXBvcnRhbnRcIj5cclxuICpcclxuICogVGhlIGhlbHBlciBzZXRzIHVwIGdsb2JhbCB2YXJpYWJsZXMgdG8gaG9sZCB0aGUgc2hhcmVkIEFuZ3VsYXIgYW5kIEFuZ3VsYXJKUyBpbmplY3RvcnMuXHJcbiAqXHJcbiAqICogT25seSBjYWxsIHRoaXMgaGVscGVyIG9uY2UgcGVyIHNwZWMuXHJcbiAqICogRG8gbm90IHVzZSBgY3JlYXRlQW5ndWxhckpTVGVzdGluZ01vZHVsZWAgaW4gdGhlIHNhbWUgc3BlYyBhcyBgY3JlYXRlQW5ndWxhclRlc3RpbmdNb2R1bGVgLlxyXG4gKlxyXG4gKiA8L2Rpdj5cclxuICpcclxuICogSGVyZSBpcyB0aGUgZXhhbXBsZSBhcHBsaWNhdGlvbiBhbmQgaXRzIHVuaXQgdGVzdHMgdGhhdCB1c2UgYGNyZWF0ZUFuZ3VsYXJUZXN0aW5nTW9kdWxlYFxyXG4gKiBhbmQgYGNyZWF0ZUFuZ3VsYXJKU1Rlc3RpbmdNb2R1bGVgLlxyXG4gKlxyXG4gKiA8Y29kZS10YWJzPlxyXG4gKiAgPGNvZGUtcGFuZSBoZWFkZXI9XCJtb2R1bGUuc3BlYy50c1wiIHBhdGg9XCJ1cGdyYWRlL3N0YXRpYy90cy9mdWxsL21vZHVsZS5zcGVjLnRzXCI+PC9jb2RlLXBhbmU+XHJcbiAqICA8Y29kZS1wYW5lIGhlYWRlcj1cIm1vZHVsZS50c1wiIHBhdGg9XCJ1cGdyYWRlL3N0YXRpYy90cy9mdWxsL21vZHVsZS50c1wiPjwvY29kZS1wYW5lPlxyXG4gKiA8L2NvZGUtdGFicz5cclxuICpcclxuICpcclxuICogQHBhcmFtIGFuZ3VsYXJNb2R1bGVzIGEgY29sbGVjdGlvbiBvZiBBbmd1bGFyIG1vZHVsZXMgdG8gaW5jbHVkZSBpbiB0aGUgY29uZmlndXJhdGlvbi5cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gY3JlYXRlQW5ndWxhckpTVGVzdGluZ01vZHVsZShhbmd1bGFyTW9kdWxlczogYW55W10pOiBzdHJpbmc7XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gdXNlIHdoZW4gdW5pdCB0ZXN0aW5nIEFuZ3VsYXIgc2VydmljZXMgdGhhdCBkZXBlbmQgdXBvbiB1cGdyYWRlZCBBbmd1bGFySlNcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgTmdNb2R1bGVgIGRlY29yYXRlZCBjbGFzcyB0aGF0IGlzIGNvbmZpZ3VyZWQgdG8gd2lyZSB1cCB0aGUgQW5ndWxhclxyXG4gKiBhbmQgQW5ndWxhckpTIGluamVjdG9ycyB3aXRob3V0IHRoZSBuZWVkIHRvIGFjdHVhbGx5IGJvb3RzdHJhcCBhIGh5YnJpZCBhcHBsaWNhdGlvbi5cclxuICogVGhpcyBtYWtlcyBpdCBzaW1wbGVyIGFuZCBmYXN0ZXIgdG8gdW5pdCB0ZXN0IHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBVc2UgdGhlIHJldHVybmVkIGNsYXNzIGFzIGFuIFwiaW1wb3J0XCIgd2hlbiBjb25maWd1cmluZyB0aGUgYFRlc3RCZWRgLlxyXG4gKlxyXG4gKiBJbiB0aGUgZm9sbG93aW5nIGNvZGUgc25pcHBldCwgd2UgYXJlIGNvbmZpZ3VyaW5nIHRoZSBUZXN0QmVkIHdpdGggdHdvIGltcG9ydHMuXHJcbiAqIFRoZSBgTmcyQXBwTW9kdWxlYCBpcyB0aGUgQW5ndWxhciBwYXJ0IG9mIG91ciBoeWJyaWQgYXBwbGljYXRpb24gYW5kIHRoZSBgbmcxQXBwTW9kdWxlYCBpcyB0aGVcclxuICogQW5ndWxhckpTIHBhcnQuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnNwZWMudHNcIiByZWdpb249XCJhbmd1bGFyLXNldHVwXCI+PC9jb2RlLWV4YW1wbGU+XHJcbiAqXHJcbiAqIE9uY2UgdGhpcyBpcyBkb25lIHdlIGNhbiBnZXQgaG9sZCBvZiBzZXJ2aWNlcyB2aWEgdGhlIEFuZ3VsYXIgYEluamVjdG9yYCBhcyBub3JtYWwuXHJcbiAqIFNlcnZpY2VzIHRoYXQgYXJlIChvciBoYXZlIGRlcGVuZGVuY2llcyBvbikgYW4gdXBncmFkZWQgQW5ndWxhckpTIHNlcnZpY2UsIHdpbGwgYmUgaW5zdGFudGlhdGVkXHJcbiAqIGFzIG5lZWRlZCBieSB0aGUgQW5ndWxhckpTIGAkaW5qZWN0b3JgLlxyXG4gKlxyXG4gKiBJbiB0aGUgZm9sbG93aW5nIGNvZGUgc25pcHBldCwgYEhlcm9lc1NlcnZpY2VgIGlzIGFuIEFuZ3VsYXIgc2VydmljZSB0aGF0IGRlcGVuZHMgdXBvbiBhblxyXG4gKiBBbmd1bGFySlMgc2VydmljZSwgYHRpdGxlQ2FzZWAuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnNwZWMudHNcIiByZWdpb249XCJhbmd1bGFyLXNwZWNcIj48L2NvZGUtZXhhbXBsZT5cclxuICpcclxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGlzLWltcG9ydGFudFwiPlxyXG4gKlxyXG4gKiBUaGlzIGhlbHBlciBpcyBmb3IgdGVzdGluZyBzZXJ2aWNlcyBub3QgQ29tcG9uZW50cy5cclxuICogRm9yIENvbXBvbmVudCB0ZXN0aW5nIHlvdSBtdXN0IHN0aWxsIGJvb3RzdHJhcCBhIGh5YnJpZCBhcHAuIFNlZSBgVXBncmFkZU1vZHVsZWAgb3JcclxuICogYGRvd25ncmFkZU1vZHVsZWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgaXMtaW1wb3J0YW50XCI+XHJcbiAqXHJcbiAqIFRoZSByZXN1bHRpbmcgY29uZmlndXJhdGlvbiBkb2VzIG5vdCB3aXJlIHVwIEFuZ3VsYXJKUyBkaWdlc3RzIHRvIFpvbmUgaG9va3MuIEl0IGlzIHRoZVxyXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgdGVzdCB3cml0ZXIgdG8gY2FsbCBgJHJvb3RTY29wZS4kYXBwbHlgLCBhcyBuZWNlc3NhcnksIHRvIHRyaWdnZXJcclxuICogQW5ndWxhckpTIGhhbmRsZXJzIG9mIGFzeW5jIGV2ZW50cyBmcm9tIEFuZ3VsYXIuXHJcbiAqXHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgaXMtaW1wb3J0YW50XCI+XHJcbiAqXHJcbiAqIFRoZSBoZWxwZXIgc2V0cyB1cCBnbG9iYWwgdmFyaWFibGVzIHRvIGhvbGQgdGhlIHNoYXJlZCBBbmd1bGFyIGFuZCBBbmd1bGFySlMgaW5qZWN0b3JzLlxyXG4gKlxyXG4gKiAqIE9ubHkgY2FsbCB0aGlzIGhlbHBlciBvbmNlIHBlciBzcGVjLlxyXG4gKiAqIERvIG5vdCB1c2UgYGNyZWF0ZUFuZ3VsYXJUZXN0aW5nTW9kdWxlYCBpbiB0aGUgc2FtZSBzcGVjIGFzIGBjcmVhdGVBbmd1bGFySlNUZXN0aW5nTW9kdWxlYC5cclxuICpcclxuICogPC9kaXY+XHJcbiAqXHJcbiAqIEhlcmUgaXMgdGhlIGV4YW1wbGUgYXBwbGljYXRpb24gYW5kIGl0cyB1bml0IHRlc3RzIHRoYXQgdXNlIGBjcmVhdGVBbmd1bGFyVGVzdGluZ01vZHVsZWBcclxuICogYW5kIGBjcmVhdGVBbmd1bGFySlNUZXN0aW5nTW9kdWxlYC5cclxuICpcclxuICogPGNvZGUtdGFicz5cclxuICogIDxjb2RlLXBhbmUgaGVhZGVyPVwibW9kdWxlLnNwZWMudHNcIiBwYXRoPVwidXBncmFkZS9zdGF0aWMvdHMvZnVsbC9tb2R1bGUuc3BlYy50c1wiPjwvY29kZS1wYW5lPlxyXG4gKiAgPGNvZGUtcGFuZSBoZWFkZXI9XCJtb2R1bGUudHNcIiBwYXRoPVwidXBncmFkZS9zdGF0aWMvdHMvZnVsbC9tb2R1bGUudHNcIj48L2NvZGUtcGFuZT5cclxuICogPC9jb2RlLXRhYnM+XHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBhbmd1bGFySlNNb2R1bGVzIGEgY29sbGVjdGlvbiBvZiB0aGUgbmFtZXMgb2YgQW5ndWxhckpTIG1vZHVsZXMgdG8gaW5jbHVkZSBpbiB0aGVcclxuICogY29uZmlndXJhdGlvbi5cclxuICogQHBhcmFtIFtzdHJpY3REaV0gd2hldGhlciB0aGUgQW5ndWxhckpTIGluamVjdG9yIHNob3VsZCBoYXZlIGBzdHJpY3RESWAgZW5hYmxlZC5cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gY3JlYXRlQW5ndWxhclRlc3RpbmdNb2R1bGUoYW5ndWxhckpTTW9kdWxlczogc3RyaW5nW10sIHN0cmljdERpPzogYm9vbGVhbik6IFR5cGU8YW55PjtcclxuXHJcbmRlY2xhcmUgdHlwZSBEaXJlY3RpdmVSZXF1aXJlUHJvcGVydHkgPSBTaW5nbGVPckxpc3RPck1hcDxzdHJpbmc+O1xyXG5cclxuZGVjbGFyZSB0eXBlIERpcmVjdGl2ZVRyYW5zY2x1ZGVQcm9wZXJ0eSA9IGJvb2xlYW4gfCAnZWxlbWVudCcgfCB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcbn07XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJQW5ndWxhckJvb3RzdHJhcENvbmZpZyB7XHJcbiAgICBzdHJpY3REaT86IGJvb2xlYW47XHJcbn1cclxuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIElBbm5vdGF0ZWRGdW5jdGlvbiBleHRlbmRzIEZ1bmN0aW9uIHtcclxuICAgICRpbmplY3Q/OiBGdW5jdGlvbiBleHRlbmRzIHtcclxuICAgICAgICAkaW5qZWN0Pzogc3RyaW5nW107XHJcbiAgICB9ID8gTmcxVG9rZW5bXSA6IFJlYWRvbmx5QXJyYXk8TmcxVG9rZW4+O1xyXG59XHJcblxyXG5kZWNsYXJlIHR5cGUgSUF1Z21lbnRlZEpRdWVyeSA9IE5vZGVbXSAmIHtcclxuICAgIG9uPzogKG5hbWU6IHN0cmluZywgZm46ICgpID0+IHZvaWQpID0+IHZvaWQ7XHJcbiAgICBkYXRhPzogKG5hbWU6IHN0cmluZywgdmFsdWU/OiBhbnkpID0+IGFueTtcclxuICAgIHRleHQ/OiAoKSA9PiBzdHJpbmc7XHJcbiAgICBpbmhlcml0ZWREYXRhPzogKG5hbWU6IHN0cmluZywgdmFsdWU/OiBhbnkpID0+IGFueTtcclxuICAgIGNvbnRlbnRzPzogKCkgPT4gSUF1Z21lbnRlZEpRdWVyeTtcclxuICAgIHBhcmVudD86ICgpID0+IElBdWdtZW50ZWRKUXVlcnk7XHJcbiAgICBlbXB0eT86ICgpID0+IHZvaWQ7XHJcbiAgICBhcHBlbmQ/OiAoY29udGVudDogSUF1Z21lbnRlZEpRdWVyeSB8IHN0cmluZykgPT4gSUF1Z21lbnRlZEpRdWVyeTtcclxuICAgIGNvbnRyb2xsZXI/OiAobmFtZTogc3RyaW5nKSA9PiBhbnk7XHJcbiAgICBpc29sYXRlU2NvcGU/OiAoKSA9PiBJU2NvcGU7XHJcbiAgICBpbmplY3Rvcj86ICgpID0+IElJbmplY3RvclNlcnZpY2U7XHJcbiAgICB0cmlnZ2VySGFuZGxlcj86IChldmVudFR5cGVPck9iamVjdDogc3RyaW5nIHwgRXZlbnQsIGV4dHJhUGFyYW1ldGVycz86IGFueVtdKSA9PiBJQXVnbWVudGVkSlF1ZXJ5O1xyXG4gICAgcmVtb3ZlPzogKCkgPT4gdm9pZDtcclxuICAgIHJlbW92ZURhdGE/OiAoKSA9PiB2b2lkO1xyXG59O1xyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSUNvbXBvbmVudCB7XHJcbiAgICBiaW5kaW5ncz86IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgY29udHJvbGxlcj86IHN0cmluZyB8IElJbmplY3RhYmxlO1xyXG4gICAgY29udHJvbGxlckFzPzogc3RyaW5nO1xyXG4gICAgcmVxdWlyZT86IERpcmVjdGl2ZVJlcXVpcmVQcm9wZXJ0eTtcclxuICAgIHRlbXBsYXRlPzogc3RyaW5nIHwgRnVuY3Rpb247XHJcbiAgICB0ZW1wbGF0ZVVybD86IHN0cmluZyB8IEZ1bmN0aW9uO1xyXG4gICAgdHJhbnNjbHVkZT86IERpcmVjdGl2ZVRyYW5zY2x1ZGVQcm9wZXJ0eTtcclxufVxyXG5cclxuZGVjbGFyZSB0eXBlIElJbmplY3RhYmxlID0gKE5nMVRva2VuIHwgRnVuY3Rpb24pW10gfCBJQW5ub3RhdGVkRnVuY3Rpb247XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJSW5qZWN0b3JTZXJ2aWNlIHtcclxuICAgIGdldChrZXk6IHN0cmluZyk6IGFueTtcclxuICAgIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW47XHJcbn1cclxuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIElNb2R1bGUge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgcmVxdWlyZXM6IChzdHJpbmcgfCBJSW5qZWN0YWJsZSlbXTtcclxuICAgIGNvbmZpZyhmbjogSUluamVjdGFibGUpOiBJTW9kdWxlO1xyXG4gICAgZGlyZWN0aXZlKHNlbGVjdG9yOiBzdHJpbmcsIGZhY3Rvcnk6IElJbmplY3RhYmxlKTogSU1vZHVsZTtcclxuICAgIGNvbXBvbmVudChzZWxlY3Rvcjogc3RyaW5nLCBjb21wb25lbnQ6IElDb21wb25lbnQpOiBJTW9kdWxlO1xyXG4gICAgY29udHJvbGxlcihuYW1lOiBzdHJpbmcsIHR5cGU6IElJbmplY3RhYmxlKTogSU1vZHVsZTtcclxuICAgIGZhY3Rvcnkoa2V5OiBOZzFUb2tlbiwgZmFjdG9yeUZuOiBJSW5qZWN0YWJsZSk6IElNb2R1bGU7XHJcbiAgICB2YWx1ZShrZXk6IE5nMVRva2VuLCB2YWx1ZTogYW55KTogSU1vZHVsZTtcclxuICAgIGNvbnN0YW50KHRva2VuOiBOZzFUb2tlbiwgdmFsdWU6IGFueSk6IElNb2R1bGU7XHJcbiAgICBydW4oYTogSUluamVjdGFibGUpOiBJTW9kdWxlO1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJUm9vdFNjb3BlU2VydmljZSB7XHJcbiAgICAkbmV3KGlzb2xhdGU/OiBib29sZWFuKTogSVNjb3BlO1xyXG4gICAgJGlkOiBzdHJpbmc7XHJcbiAgICAkcGFyZW50OiBJU2NvcGU7XHJcbiAgICAkcm9vdDogSVNjb3BlO1xyXG4gICAgJHdhdGNoKGV4cDogTmcxRXhwcmVzc2lvbiwgZm4/OiAoYTE/OiBhbnksIGEyPzogYW55KSA9PiB2b2lkKTogRnVuY3Rpb247XHJcbiAgICAkb24oZXZlbnQ6IHN0cmluZywgZm4/OiAoZXZlbnQ/OiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogRnVuY3Rpb247XHJcbiAgICAkZGVzdHJveSgpOiBhbnk7XHJcbiAgICAkYXBwbHkoZXhwPzogTmcxRXhwcmVzc2lvbik6IGFueTtcclxuICAgICRkaWdlc3QoKTogYW55O1xyXG4gICAgJGV2YWxBc3luYyhleHA6IE5nMUV4cHJlc3Npb24sIGxvY2Fscz86IGFueSk6IHZvaWQ7XHJcbiAgICAkb24oZXZlbnQ6IHN0cmluZywgZm4/OiAoZXZlbnQ/OiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogRnVuY3Rpb247XHJcbiAgICAkJGNoaWxkVGFpbDogSVNjb3BlO1xyXG4gICAgJCRjaGlsZEhlYWQ6IElTY29wZTtcclxuICAgICQkbmV4dFNpYmxpbmc6IElTY29wZTtcclxuICAgIFtrZXk6IHN0cmluZ106IGFueTtcclxufVxyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSVNjb3BlIGV4dGVuZHMgSVJvb3RTY29wZVNlcnZpY2Uge1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJVGVzdGFiaWxpdHlTZXJ2aWNlIHtcclxuICAgIGZpbmRCaW5kaW5ncyhlbGVtZW50OiBFbGVtZW50LCBleHByZXNzaW9uOiBzdHJpbmcsIG9wdF9leGFjdE1hdGNoPzogYm9vbGVhbik6IEVsZW1lbnRbXTtcclxuICAgIGZpbmRNb2RlbHMoZWxlbWVudDogRWxlbWVudCwgZXhwcmVzc2lvbjogc3RyaW5nLCBvcHRfZXhhY3RNYXRjaD86IGJvb2xlYW4pOiBFbGVtZW50W107XHJcbiAgICBnZXRMb2NhdGlvbigpOiBzdHJpbmc7XHJcbiAgICBzZXRMb2NhdGlvbih1cmw6IHN0cmluZyk6IHZvaWQ7XHJcbiAgICB3aGVuU3RhYmxlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQ7XHJcbn1cclxuXHJcbmRlY2xhcmUgdHlwZSBOZzFFeHByZXNzaW9uID0gc3RyaW5nIHwgRnVuY3Rpb247XHJcblxyXG5cclxuZGVjbGFyZSB0eXBlIE5nMVRva2VuID0gc3RyaW5nO1xyXG5cclxuZGVjbGFyZSB0eXBlIFNpbmdsZU9yTGlzdE9yTWFwPFQ+ID0gVCB8IFRbXSB8IHtcclxuICAgIFtrZXk6IHN0cmluZ106IFQ7XHJcbn07XHJcblxyXG5leHBvcnQgZGVjbGFyZSBjb25zdCDJtWFuZ3VsYXJfcGFja2FnZXNfdXBncmFkZV9zdGF0aWNfdGVzdGluZ190ZXN0aW5nX2E6IHR5cGVvZiBhbmd1bGFyLm1vZHVsZTtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IMm1YW5ndWxhcl9wYWNrYWdlc191cGdyYWRlX3N0YXRpY190ZXN0aW5nX3Rlc3RpbmdfYiA9IFwiJCRhbmd1bGFyVXBncmFkZUFwcFR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IGVudW0gybVhbmd1bGFyX3BhY2thZ2VzX3VwZ3JhZGVfc3RhdGljX3Rlc3RpbmdfdGVzdGluZ19jIHtcclxuICAgIE5vbmUgPSAwLFxyXG4gICAgRHluYW1pYyA9IDEsXHJcbiAgICBTdGF0aWMgPSAyLFxyXG4gICAgTGl0ZSA9IDNcclxufVxyXG5cclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgybVhbmd1bGFyX3BhY2thZ2VzX3VwZ3JhZGVfc3RhdGljX3Rlc3RpbmdfdGVzdGluZ19kID0gXCIkJGFuZ3VsYXJJbmplY3RvclwiO1xyXG5cclxuZXhwb3J0IHsgfVxyXG4iXX0=