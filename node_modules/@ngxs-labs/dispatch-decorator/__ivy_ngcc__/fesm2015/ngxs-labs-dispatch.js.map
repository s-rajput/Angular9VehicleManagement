{"version":3,"file":"ngxs-labs-dispatch.js","sources":["ng:/@ngxs-labs/dispatch-decorator/lib/core/internals/static-injector.ts","ng:/@ngxs-labs/dispatch-decorator/lib/dispatch.module.ts","ng:/@ngxs-labs/dispatch-decorator/lib/core/internals/action-completer.ts","ng:/@ngxs-labs/dispatch-decorator/lib/core/internals/distribute-actions.ts","ng:/@ngxs-labs/dispatch-decorator/lib/core/decorators/dispatch.ts"],"names":["isPromise"],"mappings":"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","sourcesContent":["import { Injector, NgZone } from '@angular/core';\nimport { Store } from '@ngxs/store';\n\nclass NgxsDispatchPluginModuleNotImported extends Error {\n  message = 'NgxsDispatchPluginModule is not imported';\n}\n\nlet injector: Injector | null = null;\n\nfunction assertDefined<T>(actual: T | null | undefined): never | void {\n  if (actual == null) {\n    throw new NgxsDispatchPluginModuleNotImported();\n  }\n}\n\nexport function setInjector(parentInjector: Injector): void {\n  injector = parentInjector;\n}\n\nexport function getStore(): never | Store {\n  assertDefined(injector);\n  return injector!.get<Store>(Store);\n}\n\nexport function getNgZone(): never | NgZone {\n  assertDefined(injector);\n  return injector!.get<NgZone>(NgZone);\n}\n","import { NgModule, ModuleWithProviders, Injector } from '@angular/core';\n\nimport { setInjector } from './core/internals/static-injector';\n\n@NgModule()\nexport class NgxsDispatchPluginModule {\n  constructor(injector: Injector) {\n    setInjector(injector);\n  }\n\n  static forRoot(): ModuleWithProviders<NgxsDispatchPluginModule> {\n    return {\n      ngModule: NgxsDispatchPluginModule\n    };\n  }\n}\n","import { Subject } from 'rxjs';\n\nexport class ActionCompleter {\n  cancelUncompleted$ = new Subject<void>();\n\n  static create(cancelUncompleted: boolean): ActionCompleter | null {\n    if (cancelUncompleted) {\n      // Allocate memory lazily only if `cancelUncompleted` is truthy\n      return new ActionCompleter();\n    }\n\n    return null;\n  }\n\n  cancelPreviousAction(): void {\n    this.cancelUncompleted$.next();\n  }\n}\n","import { ÉµisPromise as isPromise } from '@angular/core';\nimport { isObservable, Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport { ActionCompleter } from './action-completer';\nimport { Wrapped, ActionOrActions } from './internals';\nimport { getStore, getNgZone } from './static-injector';\n\nfunction dispatchFactory(actionOrActions: ActionOrActions): void {\n  const store = getStore();\n  const ngZone = getNgZone();\n  ngZone.run(() => store.dispatch(actionOrActions));\n}\n\nfunction unwrapObservable(\n  wrapped: Observable<ActionOrActions>,\n  actionCompleter: ActionCompleter | null\n): Observable<ActionOrActions> {\n  // If it is not nully then it means `cancelUncompleted` is truthy\n  if (actionCompleter !== null) {\n    wrapped = wrapped.pipe(takeUntil(actionCompleter.cancelUncompleted$));\n  }\n\n  wrapped.subscribe({\n    next: actionOrActions => dispatchFactory(actionOrActions)\n  });\n\n  return wrapped;\n}\n\nasync function unwrapPromise(wrapped: Promise<ActionOrActions>): Promise<ActionOrActions> {\n  const actionOrActions = await wrapped;\n  dispatchFactory(actionOrActions);\n  return actionOrActions;\n}\n\n/**\n * As dispatchers can have different return types, they can be either\n * synchronous or asynchronous, we have to determine its return type\n * and unwrap `Promise` or `Observable`\n */\nexport function distributeActions(wrapped: Wrapped, actionCompleter: ActionCompleter | null) {\n  if (isObservable(wrapped)) {\n    return unwrapObservable(wrapped, actionCompleter);\n  }\n\n  if (isPromise(wrapped)) {\n    return unwrapPromise(wrapped);\n  }\n\n  dispatchFactory(wrapped);\n  return wrapped;\n}\n","import { DispatchOptions } from '../internals/internals';\nimport { getNgZone } from '../internals/static-injector';\nimport { ActionCompleter } from '../internals/action-completer';\nimport { distributeActions } from '../internals/distribute-actions';\n\nfunction isMethodDecorator(descriptor?: any): descriptor is TypedPropertyDescriptor<Function> {\n  return !!descriptor && typeof descriptor.value === 'function';\n}\n\nexport function Dispatch(\n  options: DispatchOptions = { cancelUncompleted: false }\n): PropertyDecorator {\n  return (\n    target: any,\n    propertyKey: string | symbol,\n    descriptor?: TypedPropertyDescriptor<Function>\n  ) => {\n    let originalValue: Function = null!;\n\n    const actionCompleter = ActionCompleter.create(options.cancelUncompleted!);\n\n    function wrapped(this: any) {\n      // Every time the function is invoked we have to generate event\n      // to cancel previously uncompleted asynchronous job\n      if (actionCompleter !== null) {\n        actionCompleter.cancelPreviousAction();\n      }\n\n      const ngZone = getNgZone();\n      const wrapped = originalValue.apply(this, arguments);\n      return ngZone.runOutsideAngular(() => distributeActions(wrapped, actionCompleter));\n    }\n\n    if (isMethodDecorator(descriptor)) {\n      originalValue = descriptor.value!;\n      descriptor.value = wrapped;\n    } else {\n      Object.defineProperty(target, propertyKey, {\n        set: value => (originalValue = value),\n        get: () => wrapped\n      });\n    }\n  };\n}\n"]}