import { NgZone, NgModule, Injector, ɵisPromise } from '@angular/core';
import { __extends, __awaiter, __generator } from 'tslib';
import { Store } from '@ngxs/store';
import { Subject, isObservable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxsDispatchPluginModuleNotImported = /** @class */ (function (_super) {
    __extends(NgxsDispatchPluginModuleNotImported, _super);
    function NgxsDispatchPluginModuleNotImported() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.message = 'NgxsDispatchPluginModule is not imported';
        return _this;
    }
    return NgxsDispatchPluginModuleNotImported;
}(Error));
if (false) {
    /** @type {?} */
    NgxsDispatchPluginModuleNotImported.prototype.message;
}
/** @type {?} */
var injector = null;
/**
 * @template T
 * @param {?} actual
 * @return {?}
 */
function assertDefined(actual) {
    if (actual == null) {
        throw new NgxsDispatchPluginModuleNotImported();
    }
}
/**
 * @param {?} parentInjector
 * @return {?}
 */
function setInjector(parentInjector) {
    injector = parentInjector;
}
/**
 * @return {?}
 */
function getStore() {
    assertDefined(injector);
    return (/** @type {?} */ (injector)).get(Store);
}
/**
 * @return {?}
 */
function getNgZone() {
    assertDefined(injector);
    return (/** @type {?} */ (injector)).get(NgZone);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxsDispatchPluginModule = /** @class */ (function () {
    function NgxsDispatchPluginModule(injector) {
        setInjector(injector);
    }
    /**
     * @return {?}
     */
    NgxsDispatchPluginModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: NgxsDispatchPluginModule
        };
    };
    NgxsDispatchPluginModule.decorators = [
        { type: NgModule }
    ];
    /** @nocollapse */
    NgxsDispatchPluginModule.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    return NgxsDispatchPluginModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionCompleter = /** @class */ (function () {
    function ActionCompleter() {
        this.cancelUncompleted$ = new Subject();
    }
    /**
     * @param {?} cancelUncompleted
     * @return {?}
     */
    ActionCompleter.create = /**
     * @param {?} cancelUncompleted
     * @return {?}
     */
    function (cancelUncompleted) {
        if (cancelUncompleted) {
            // Allocate memory lazily only if `cancelUncompleted` is truthy
            return new ActionCompleter();
        }
        return null;
    };
    /**
     * @return {?}
     */
    ActionCompleter.prototype.cancelPreviousAction = /**
     * @return {?}
     */
    function () {
        this.cancelUncompleted$.next();
    };
    return ActionCompleter;
}());
if (false) {
    /** @type {?} */
    ActionCompleter.prototype.cancelUncompleted$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} actionOrActions
 * @return {?}
 */
function dispatchFactory(actionOrActions) {
    /** @type {?} */
    var store = getStore();
    /** @type {?} */
    var ngZone = getNgZone();
    ngZone.run((/**
     * @return {?}
     */
    function () { return store.dispatch(actionOrActions); }));
}
/**
 * @param {?} wrapped
 * @param {?} actionCompleter
 * @return {?}
 */
function unwrapObservable(wrapped, actionCompleter) {
    // If it is not nully then it means `cancelUncompleted` is truthy
    if (actionCompleter !== null) {
        wrapped = wrapped.pipe(takeUntil(actionCompleter.cancelUncompleted$));
    }
    wrapped.subscribe({
        next: (/**
         * @param {?} actionOrActions
         * @return {?}
         */
        function (actionOrActions) { return dispatchFactory(actionOrActions); })
    });
    return wrapped;
}
/**
 * @param {?} wrapped
 * @return {?}
 * @this {*}
 */
function unwrapPromise(wrapped) {
    return __awaiter(this, void 0, void 0, function () {
        var actionOrActions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, wrapped];
                case 1:
                    actionOrActions = _a.sent();
                    dispatchFactory(actionOrActions);
                    return [2 /*return*/, actionOrActions];
            }
        });
    });
}
/**
 * As dispatchers can have different return types, they can be either
 * synchronous or asynchronous, we have to determine its return type
 * and unwrap `Promise` or `Observable`
 * @param {?} wrapped
 * @param {?} actionCompleter
 * @return {?}
 */
function distributeActions(wrapped, actionCompleter) {
    if (isObservable(wrapped)) {
        return unwrapObservable(wrapped, actionCompleter);
    }
    if (ɵisPromise(wrapped)) {
        return unwrapPromise(wrapped);
    }
    dispatchFactory(wrapped);
    return wrapped;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} descriptor
 * @return {?}
 */
function isMethodDecorator(descriptor) {
    return !!descriptor && typeof descriptor.value === 'function';
}
/**
 * @param {?=} options
 * @return {?}
 */
function Dispatch(options) {
    if (options === void 0) { options = { cancelUncompleted: false }; }
    return (/**
     * @param {?} target
     * @param {?} propertyKey
     * @param {?=} descriptor
     * @return {?}
     */
    function (target, propertyKey, descriptor) {
        /** @type {?} */
        var originalValue = (/** @type {?} */ (null));
        /** @type {?} */
        var actionCompleter = ActionCompleter.create((/** @type {?} */ (options.cancelUncompleted)));
        /**
         * @this {?}
         * @return {?}
         */
        function wrapped() {
            // Every time the function is invoked we have to generate event
            // to cancel previously uncompleted asynchronous job
            if (actionCompleter !== null) {
                actionCompleter.cancelPreviousAction();
            }
            /** @type {?} */
            var ngZone = getNgZone();
            /** @type {?} */
            var wrapped = originalValue.apply(this, arguments);
            return ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () { return distributeActions(wrapped, actionCompleter); }));
        }
        if (isMethodDecorator(descriptor)) {
            originalValue = (/** @type {?} */ (descriptor.value));
            descriptor.value = wrapped;
        }
        else {
            Object.defineProperty(target, propertyKey, {
                set: (/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) { return (originalValue = value); }),
                get: (/**
                 * @return {?}
                 */
                function () { return wrapped; })
            });
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Dispatch, NgxsDispatchPluginModule };
//# sourceMappingURL=ngxs-labs-dispatch.js.map
