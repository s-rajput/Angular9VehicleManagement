import { NgZone, NgModule, Injector, ɵisPromise } from '@angular/core';
import { Store } from '@ngxs/store';
import { Subject, isObservable } from 'rxjs';
import { __awaiter } from 'tslib';
import { takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxsDispatchPluginModuleNotImported extends Error {
    constructor() {
        super(...arguments);
        this.message = 'NgxsDispatchPluginModule is not imported';
    }
}
if (false) {
    /** @type {?} */
    NgxsDispatchPluginModuleNotImported.prototype.message;
}
/** @type {?} */
let injector = null;
/**
 * @template T
 * @param {?} actual
 * @return {?}
 */
function assertDefined(actual) {
    if (actual == null) {
        throw new NgxsDispatchPluginModuleNotImported();
    }
}
/**
 * @param {?} parentInjector
 * @return {?}
 */
function setInjector(parentInjector) {
    injector = parentInjector;
}
/**
 * @return {?}
 */
function getStore() {
    assertDefined(injector);
    return (/** @type {?} */ (injector)).get(Store);
}
/**
 * @return {?}
 */
function getNgZone() {
    assertDefined(injector);
    return (/** @type {?} */ (injector)).get(NgZone);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxsDispatchPluginModule {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        setInjector(injector);
    }
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxsDispatchPluginModule
        };
    }
}
NgxsDispatchPluginModule.decorators = [
    { type: NgModule }
];
/** @nocollapse */
NgxsDispatchPluginModule.ctorParameters = () => [
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionCompleter {
    constructor() {
        this.cancelUncompleted$ = new Subject();
    }
    /**
     * @param {?} cancelUncompleted
     * @return {?}
     */
    static create(cancelUncompleted) {
        if (cancelUncompleted) {
            // Allocate memory lazily only if `cancelUncompleted` is truthy
            return new ActionCompleter();
        }
        return null;
    }
    /**
     * @return {?}
     */
    cancelPreviousAction() {
        this.cancelUncompleted$.next();
    }
}
if (false) {
    /** @type {?} */
    ActionCompleter.prototype.cancelUncompleted$;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} actionOrActions
 * @return {?}
 */
function dispatchFactory(actionOrActions) {
    /** @type {?} */
    const store = getStore();
    /** @type {?} */
    const ngZone = getNgZone();
    ngZone.run((/**
     * @return {?}
     */
    () => store.dispatch(actionOrActions)));
}
/**
 * @param {?} wrapped
 * @param {?} actionCompleter
 * @return {?}
 */
function unwrapObservable(wrapped, actionCompleter) {
    // If it is not nully then it means `cancelUncompleted` is truthy
    if (actionCompleter !== null) {
        wrapped = wrapped.pipe(takeUntil(actionCompleter.cancelUncompleted$));
    }
    wrapped.subscribe({
        next: (/**
         * @param {?} actionOrActions
         * @return {?}
         */
        actionOrActions => dispatchFactory(actionOrActions))
    });
    return wrapped;
}
/**
 * @param {?} wrapped
 * @return {?}
 * @this {*}
 */
function unwrapPromise(wrapped) {
    return __awaiter(this, void 0, void 0, function* () {
        /** @type {?} */
        const actionOrActions = yield wrapped;
        dispatchFactory(actionOrActions);
        return actionOrActions;
    });
}
/**
 * As dispatchers can have different return types, they can be either
 * synchronous or asynchronous, we have to determine its return type
 * and unwrap `Promise` or `Observable`
 * @param {?} wrapped
 * @param {?} actionCompleter
 * @return {?}
 */
function distributeActions(wrapped, actionCompleter) {
    if (isObservable(wrapped)) {
        return unwrapObservable(wrapped, actionCompleter);
    }
    if (ɵisPromise(wrapped)) {
        return unwrapPromise(wrapped);
    }
    dispatchFactory(wrapped);
    return wrapped;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} descriptor
 * @return {?}
 */
function isMethodDecorator(descriptor) {
    return !!descriptor && typeof descriptor.value === 'function';
}
/**
 * @param {?=} options
 * @return {?}
 */
function Dispatch(options = { cancelUncompleted: false }) {
    return (/**
     * @param {?} target
     * @param {?} propertyKey
     * @param {?=} descriptor
     * @return {?}
     */
    (target, propertyKey, descriptor) => {
        /** @type {?} */
        let originalValue = (/** @type {?} */ (null));
        /** @type {?} */
        const actionCompleter = ActionCompleter.create((/** @type {?} */ (options.cancelUncompleted)));
        /**
         * @this {?}
         * @return {?}
         */
        function wrapped() {
            // Every time the function is invoked we have to generate event
            // to cancel previously uncompleted asynchronous job
            if (actionCompleter !== null) {
                actionCompleter.cancelPreviousAction();
            }
            /** @type {?} */
            const ngZone = getNgZone();
            /** @type {?} */
            const wrapped = originalValue.apply(this, arguments);
            return ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => distributeActions(wrapped, actionCompleter)));
        }
        if (isMethodDecorator(descriptor)) {
            originalValue = (/** @type {?} */ (descriptor.value));
            descriptor.value = wrapped;
        }
        else {
            Object.defineProperty(target, propertyKey, {
                set: (/**
                 * @param {?} value
                 * @return {?}
                 */
                value => (originalValue = value)),
                get: (/**
                 * @return {?}
                 */
                () => wrapped)
            });
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Dispatch, NgxsDispatchPluginModule };
//# sourceMappingURL=ngxs-labs-dispatch.js.map
