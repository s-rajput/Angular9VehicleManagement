{"version":3,"file":"ngxs-labs-dispatch.js","sources":["ng://@ngxs-labs/dispatch-decorator/lib/core/internals/static-injector.ts","ng://@ngxs-labs/dispatch-decorator/lib/dispatch.module.ts","ng://@ngxs-labs/dispatch-decorator/lib/core/internals/action-completer.ts","ng://@ngxs-labs/dispatch-decorator/lib/core/internals/distribute-actions.ts","ng://@ngxs-labs/dispatch-decorator/lib/core/decorators/dispatch.ts"],"sourcesContent":["import { Injector, NgZone } from '@angular/core';\nimport { Store } from '@ngxs/store';\n\nclass NgxsDispatchPluginModuleNotImported extends Error {\n  message = 'NgxsDispatchPluginModule is not imported';\n}\n\nlet injector: Injector | null = null;\n\nfunction assertDefined<T>(actual: T | null | undefined): never | void {\n  if (actual == null) {\n    throw new NgxsDispatchPluginModuleNotImported();\n  }\n}\n\nexport function setInjector(parentInjector: Injector): void {\n  injector = parentInjector;\n}\n\nexport function getStore(): never | Store {\n  assertDefined(injector);\n  return injector!.get<Store>(Store);\n}\n\nexport function getNgZone(): never | NgZone {\n  assertDefined(injector);\n  return injector!.get<NgZone>(NgZone);\n}\n","import { NgModule, ModuleWithProviders, Injector } from '@angular/core';\n\nimport { setInjector } from './core/internals/static-injector';\n\n@NgModule()\nexport class NgxsDispatchPluginModule {\n  constructor(injector: Injector) {\n    setInjector(injector);\n  }\n\n  static forRoot(): ModuleWithProviders<NgxsDispatchPluginModule> {\n    return {\n      ngModule: NgxsDispatchPluginModule\n    };\n  }\n}\n","import { Subject } from 'rxjs';\n\nexport class ActionCompleter {\n  cancelUncompleted$ = new Subject<void>();\n\n  static create(cancelUncompleted: boolean): ActionCompleter | null {\n    if (cancelUncompleted) {\n      // Allocate memory lazily only if `cancelUncompleted` is truthy\n      return new ActionCompleter();\n    }\n\n    return null;\n  }\n\n  cancelPreviousAction(): void {\n    this.cancelUncompleted$.next();\n  }\n}\n","import { ÉµisPromise as isPromise } from '@angular/core';\nimport { isObservable, Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport { ActionCompleter } from './action-completer';\nimport { Wrapped, ActionOrActions } from './internals';\nimport { getStore, getNgZone } from './static-injector';\n\nfunction dispatchFactory(actionOrActions: ActionOrActions): void {\n  const store = getStore();\n  const ngZone = getNgZone();\n  ngZone.run(() => store.dispatch(actionOrActions));\n}\n\nfunction unwrapObservable(\n  wrapped: Observable<ActionOrActions>,\n  actionCompleter: ActionCompleter | null\n): Observable<ActionOrActions> {\n  // If it is not nully then it means `cancelUncompleted` is truthy\n  if (actionCompleter !== null) {\n    wrapped = wrapped.pipe(takeUntil(actionCompleter.cancelUncompleted$));\n  }\n\n  wrapped.subscribe({\n    next: actionOrActions => dispatchFactory(actionOrActions)\n  });\n\n  return wrapped;\n}\n\nasync function unwrapPromise(wrapped: Promise<ActionOrActions>): Promise<ActionOrActions> {\n  const actionOrActions = await wrapped;\n  dispatchFactory(actionOrActions);\n  return actionOrActions;\n}\n\n/**\n * As dispatchers can have different return types, they can be either\n * synchronous or asynchronous, we have to determine its return type\n * and unwrap `Promise` or `Observable`\n */\nexport function distributeActions(wrapped: Wrapped, actionCompleter: ActionCompleter | null) {\n  if (isObservable(wrapped)) {\n    return unwrapObservable(wrapped, actionCompleter);\n  }\n\n  if (isPromise(wrapped)) {\n    return unwrapPromise(wrapped);\n  }\n\n  dispatchFactory(wrapped);\n  return wrapped;\n}\n","import { DispatchOptions } from '../internals/internals';\nimport { getNgZone } from '../internals/static-injector';\nimport { ActionCompleter } from '../internals/action-completer';\nimport { distributeActions } from '../internals/distribute-actions';\n\nfunction isMethodDecorator(descriptor?: any): descriptor is TypedPropertyDescriptor<Function> {\n  return !!descriptor && typeof descriptor.value === 'function';\n}\n\nexport function Dispatch(\n  options: DispatchOptions = { cancelUncompleted: false }\n): PropertyDecorator {\n  return (\n    target: any,\n    propertyKey: string | symbol,\n    descriptor?: TypedPropertyDescriptor<Function>\n  ) => {\n    let originalValue: Function = null!;\n\n    const actionCompleter = ActionCompleter.create(options.cancelUncompleted!);\n\n    function wrapped(this: any) {\n      // Every time the function is invoked we have to generate event\n      // to cancel previously uncompleted asynchronous job\n      if (actionCompleter !== null) {\n        actionCompleter.cancelPreviousAction();\n      }\n\n      const ngZone = getNgZone();\n      const wrapped = originalValue.apply(this, arguments);\n      return ngZone.runOutsideAngular(() => distributeActions(wrapped, actionCompleter));\n    }\n\n    if (isMethodDecorator(descriptor)) {\n      originalValue = descriptor.value!;\n      descriptor.value = wrapped;\n    } else {\n      Object.defineProperty(target, propertyKey, {\n        set: value => (originalValue = value),\n        get: () => wrapped\n      });\n    }\n  };\n}\n"],"names":["isPromise"],"mappings":"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"}