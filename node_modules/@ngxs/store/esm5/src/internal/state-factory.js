/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        var _this = this;
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var stateFactory = _this;
            /** @type {?} */
            var context = _this._parentFactory
                ? _this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter: /**
                     * @param {?} key
                     * @return {?}
                     */
                    function (key) {
                        /** @type {?} */
                        var path = stateFactory.statePaths[key];
                        return path ? propGetter(path.split('.'), stateFactory._config) : (/**
                         * @return {?}
                         */
                        function () { return undefined; });
                    },
                    getSelectorOptions: /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    function (localOptions) {
                        /** @type {?} */
                        var globalSelectorOptions = stateFactory._config.selectorOptions;
                        return tslib_1.__assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statesByName", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statePaths", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    StateFactory.cloneDefaults = /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    function (defaults) {
        /** @type {?} */
        var value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = tslib_1.__assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.checkStatesAreValid = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    };
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_1, _a;
        StateFactory.checkStatesAreValid(stateClasses);
        var newStates = this.addToStatesMap(stateClasses).newStates;
        if (!newStates.length)
            return [];
        /** @type {?} */
        var stateGraph = buildGraph(newStates);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var paths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(newStates);
        /** @type {?} */
        var bootstrappedStores = [];
        try {
            for (var sortedStates_1 = tslib_1.__values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                /** @type {?} */
                var stateClass = nameGraph[name_1];
                /** @type {?} */
                var path = paths[name_1];
                /** @type {?} */
                var meta = (/** @type {?} */ (stateClass[META_KEY]));
                this.addRuntimeInfoToMeta(meta, path);
                /** @type {?} */
                var stateMap = {
                    name: name_1,
                    path: path,
                    isInitialised: false,
                    actions: meta.actions,
                    instance: this._injector.get(stateClass),
                    defaults: StateFactory.cloneDefaults(meta.defaults)
                };
                // ensure our store hasn't already been added
                // but don't throw since it could be lazy
                // loaded from different paths
                if (!this.hasBeenMountedAndBootstrapped(name_1, path)) {
                    bootstrappedStores.push(stateMap);
                }
                this.states.push(stateMap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return bootstrappedStores;
    };
    /**
     * Add a set of states to the store and return the defaults
     */
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        /** @type {?} */
        var classes = stateClasses || [];
        /** @type {?} */
        var mappedStores = this.add(classes);
        /** @type {?} */
        var defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        function (result, mappedStore) {
            return setValue(result, mappedStore.path, mappedStore.defaults);
        }), {});
        return { defaults: defaults, states: mappedStores };
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; })), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); })), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error })));
            })));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return _this._actionResults.next(ctx); }));
        this._connected = true;
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_2, _a, e_3, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = tslib_1.__values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = (/** @type {?} */ (getActionTypeFromInstance(action)));
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = tslib_1.__values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this._stateContextFactory.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    if (actionMeta.options.cancelUncompleted) {
                                        // todo: ofActionDispatched should be used with action class
                                        result = result.pipe(takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                                    }
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addToStatesMap = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_4, _a;
        /** @type {?} */
        var newStates = [];
        /** @type {?} */
        var statesMap = this.statesByName;
        try {
            for (var stateClasses_1 = tslib_1.__values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                var stateClass = stateClasses_1_1.value;
                /** @type {?} */
                var stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
                /** @type {?} */
                var unmountedState = !statesMap[stateName];
                if (unmountedState) {
                    newStates.push(stateClass);
                    statesMap[stateName] = stateClass;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (stateClasses_1_1 && !stateClasses_1_1.done && (_a = stateClasses_1.return)) _a.call(stateClasses_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return { newStates: newStates };
    };
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.addRuntimeInfoToMeta = /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    function (meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    };
    /**
     * @description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @param name
     * @param path
     */
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.hasBeenMountedAndBootstrapped = /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    function (name, path) {
        /** @type {?} */
        var valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
    ]; };
    return StateFactory;
}());
export { StateFactory };
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRixPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRSxPQUFPLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxNQUFNLEVBQ04sR0FBRyxFQUNILFFBQVEsRUFDUixXQUFXLEVBQ1gsU0FBUyxFQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDbEQsT0FBTyxFQUNMLFVBQVUsRUFDVixrQkFBa0IsRUFDbEIsUUFBUSxFQUdSLFdBQVcsRUFDWCxVQUFVLEVBS1YsZUFBZSxFQUdoQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUseUJBQXlCLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9FLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBK0IsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakYsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDeEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzVELE9BQU8sRUFBRSxtQkFBbUIsRUFBaUIsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7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TSxTQUFDLG1CQUFtQjs7SUFrTy9CLG1CQUFDO0NBQUEsQUFoUEQsSUFnUEM7U0EvT1ksWUFBWTs7Ozs7O0lBQ3ZCLGtDQUEyQjs7Ozs7SUFnQjNCLCtCQUFvQzs7Ozs7SUFNcEMscUNBQXlDOzs7OztJQU16QyxtQ0FBZ0Q7O0lBTWhELGlEQWtCRzs7Ozs7SUFqREQsaUNBQTJCOzs7OztJQUMzQiwrQkFBMkI7Ozs7O0lBQzNCLHNDQUVvQzs7Ozs7SUFDcEMsZ0NBQWlDOzs7OztJQUNqQyxzQ0FBdUQ7Ozs7O0lBQ3ZELDRDQUFpRDs7Ozs7SUFDakQscUNBRTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGZvcmtKb2luLCBmcm9tLCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge1xyXG4gIGNhdGNoRXJyb3IsXHJcbiAgZGVmYXVsdElmRW1wdHksXHJcbiAgZmlsdGVyLFxyXG4gIG1hcCxcclxuICBtZXJnZU1hcCxcclxuICBzaGFyZVJlcGxheSxcclxuICB0YWtlVW50aWxcclxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQge1xyXG4gIGJ1aWxkR3JhcGgsXHJcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxyXG4gIGlzT2JqZWN0LFxyXG4gIE1hcHBlZFN0b3JlLFxyXG4gIE1ldGFEYXRhTW9kZWwsXHJcbiAgbmFtZVRvU3RhdGUsXHJcbiAgcHJvcEdldHRlcixcclxuICBTdGF0ZUNsYXNzSW50ZXJuYWwsXHJcbiAgU3RhdGVLZXlHcmFwaCxcclxuICBTdGF0ZXNBbmREZWZhdWx0cyxcclxuICBTdGF0ZXNCeU5hbWUsXHJcbiAgdG9wb2xvZ2ljYWxTb3J0LFxyXG4gIFJ1bnRpbWVTZWxlY3RvckNvbnRleHQsXHJcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zXHJcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBnZXRWYWx1ZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcclxuaW1wb3J0IHsgU3RvcmVWYWxpZGF0b3JzIH0gZnJvbSAnLi4vdXRpbHMvc3RvcmUtdmFsaWRhdG9ycyc7XHJcbmltcG9ydCB7IElOSVRJQUxfU1RBVEVfVE9LRU4sIFBsYWluT2JqZWN0T2YsIG1lbW9pemUgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IHtcclxuICBwcml2YXRlIF9jb25uZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQFNraXBTZWxmKClcclxuICAgIHByaXZhdGUgX3BhcmVudEZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9zdGF0ZUNvbnRleHRGYWN0b3J5OiBTdGF0ZUNvbnRleHRGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoSU5JVElBTF9TVEFURV9UT0tFTilcclxuICAgIHByaXZhdGUgX2luaXRpYWxTdGF0ZTogYW55XHJcbiAgKSB7fVxyXG5cclxuICBwcml2YXRlIF9zdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgcHVibGljIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVzQnlOYW1lOiBTdGF0ZXNCeU5hbWUgPSB7fTtcclxuXHJcbiAgcHVibGljIGdldCBzdGF0ZXNCeU5hbWUoKTogU3RhdGVzQnlOYW1lIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXNCeU5hbWUgOiB0aGlzLl9zdGF0ZXNCeU5hbWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF9zdGF0ZVBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcclxuXHJcbiAgcHJpdmF0ZSBnZXQgc3RhdGVQYXRocygpOiBQbGFpbk9iamVjdE9mPHN0cmluZz4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlUGF0aHMgOiB0aGlzLl9zdGF0ZVBhdGhzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQgPSBtZW1vaXplKCgpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlRmFjdG9yeSA9IHRoaXM7XHJcbiAgICBjb25zdCBjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gdGhpcy5fcGFyZW50RmFjdG9yeVxyXG4gICAgICA/IHRoaXMuX3BhcmVudEZhY3RvcnkuZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCgpXHJcbiAgICAgIDoge1xyXG4gICAgICAgICAgZ2V0U3RhdGVHZXR0ZXIoa2V5OiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHN0YXRlRmFjdG9yeS5zdGF0ZVBhdGhzW2tleV07XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJyksIHN0YXRlRmFjdG9yeS5fY29uZmlnKSA6ICgpID0+IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBnZXRTZWxlY3Rvck9wdGlvbnMobG9jYWxPcHRpb25zPzogU2hhcmVkU2VsZWN0b3JPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5nbG9iYWxTZWxlY3Rvck9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfSk7XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGNsb25lRGVmYXVsdHMoZGVmYXVsdHM6IGFueSk6IGFueSB7XHJcbiAgICBsZXQgdmFsdWUgPSB7fTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcclxuICAgICAgdmFsdWUgPSBkZWZhdWx0cy5zbGljZSgpO1xyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcclxuICAgICAgdmFsdWUgPSB7IC4uLmRlZmF1bHRzIH07XHJcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFsdWUgPSB7fTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gZGVmYXVsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY2hlY2tTdGF0ZXNBcmVWYWxpZChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogdm9pZCB7XHJcbiAgICBzdGF0ZUNsYXNzZXMuZm9yRWFjaChTdG9yZVZhbGlkYXRvcnMuZ2V0VmFsaWRTdGF0ZU1ldGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgU3RhdGVGYWN0b3J5LmNoZWNrU3RhdGVzQXJlVmFsaWQoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IHBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSBmaW5kRnVsbFBhcmVudFBhdGgoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBuYW1lR3JhcGg6IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPiA9IG5hbWVUb1N0YXRlKG5ld1N0YXRlcyk7XHJcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcclxuICAgICAgY29uc3QgcGF0aDogc3RyaW5nID0gcGF0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IG1ldGE6IE1ldGFEYXRhTW9kZWwgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XHJcblxyXG4gICAgICB0aGlzLmFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGEsIHBhdGgpO1xyXG5cclxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcclxuICAgICAgICBhY3Rpb25zOiBtZXRhLmFjdGlvbnMsXHJcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKSxcclxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxyXG4gICAgICAvLyBidXQgZG9uJ3QgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxyXG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcclxuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XHJcbiAgICAgICAgYm9vdHN0cmFwcGVkU3RvcmVzLnB1c2goc3RhdGVNYXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm9vdHN0cmFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsdHNcclxuICAgKi9cclxuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVzQW5kRGVmYXVsdHMge1xyXG4gICAgY29uc3QgY2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XHJcblxyXG4gICAgY29uc3QgbWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gdGhpcy5hZGQoY2xhc3Nlcyk7XHJcbiAgICBjb25zdCBkZWZhdWx0cyA9IG1hcHBlZFN0b3Jlcy5yZWR1Y2UoXHJcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxyXG4gICAgICAgIHNldFZhbHVlKHJlc3VsdCwgbWFwcGVkU3RvcmUucGF0aCwgbWFwcGVkU3RvcmUuZGVmYXVsdHMpLFxyXG4gICAgICB7fVxyXG4gICAgKTtcclxuICAgIHJldHVybiB7IGRlZmF1bHRzLCBzdGF0ZXM6IG1hcHBlZFN0b3JlcyB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcclxuICAgKi9cclxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSByZXR1cm47XHJcbiAgICB0aGlzLl9hY3Rpb25zXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XHJcbiAgICAgICAgICB0aGlzLmludm9rZUFjdGlvbnModGhpcy5fYWN0aW9ucywgYWN0aW9uISkucGlwZShcclxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxyXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT5cclxuICAgICAgICAgICAgICBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKGN0eCA9PiB0aGlzLl9hY3Rpb25SZXN1bHRzLm5leHQoY3R4KSk7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VBY3Rpb25zKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIGFjdGlvbjogYW55KSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xyXG4gICAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcclxuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogb2ZBY3Rpb25EaXNwYXRjaGVkIHNob3VsZCBiZSB1c2VkIHdpdGggYWN0aW9uIGNsYXNzXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcclxuICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGFjdGlvbnMkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbiBhcyBhbnkpKSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRUb1N0YXRlc01hcChcclxuICAgIHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW11cclxuICApOiB7IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gfSB7XHJcbiAgICBjb25zdCBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gW107XHJcbiAgICBjb25zdCBzdGF0ZXNNYXA6IFN0YXRlc0J5TmFtZSA9IHRoaXMuc3RhdGVzQnlOYW1lO1xyXG5cclxuICAgIGZvciAoY29uc3Qgc3RhdGVDbGFzcyBvZiBzdGF0ZUNsYXNzZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVOYW1lOiBzdHJpbmcgPSBTdG9yZVZhbGlkYXRvcnMuY2hlY2tTdGF0ZU5hbWVJc1VuaXF1ZShzdGF0ZUNsYXNzLCBzdGF0ZXNNYXApO1xyXG4gICAgICBjb25zdCB1bm1vdW50ZWRTdGF0ZSA9ICFzdGF0ZXNNYXBbc3RhdGVOYW1lXTtcclxuICAgICAgaWYgKHVubW91bnRlZFN0YXRlKSB7XHJcbiAgICAgICAgbmV3U3RhdGVzLnB1c2goc3RhdGVDbGFzcyk7XHJcbiAgICAgICAgc3RhdGVzTWFwW3N0YXRlTmFtZV0gPSBzdGF0ZUNsYXNzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgbmV3U3RhdGVzIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGE6IE1ldGFEYXRhTW9kZWwsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5zdGF0ZVBhdGhzW21ldGEubmFtZSFdID0gcGF0aDtcclxuICAgIC8vIFRPRE86IHY0IC0gd2UgcGxhbiB0byBnZXQgcmlkIG9mIHRoZSBwYXRoIHByb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm9uLWRldGVybWluaXN0aWNcclxuICAgIC8vIHdlIGNhbiBkbyB0aGlzIHdoZW4gd2UgZ2V0IHJpZCBvZiB0aGUgaW5jb3JyZWN0bHkgZXhwb3NlZCBnZXRTdG9yZU1ldGFkYXRhXHJcbiAgICAvLyBXZSB3aWxsIG5lZWQgdG8gY29tZSB1cCB3aXRoIGFuIGFsdGVybmF0aXZlIGluIHY0IGJlY2F1c2UgdGhpcyBpcyB1c2VkIGJ5IG1hbnkgcGx1Z2luc1xyXG4gICAgbWV0YS5wYXRoID0gcGF0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIHRoZSBtZXRob2QgY2hlY2tzIGlmIHRoZSBzdGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSB0cmVlXHJcbiAgICogYW5kIGNvbXBsZXRlZCB0aGUgbGlmZSBjeWNsZVxyXG4gICAqIEBwYXJhbSBuYW1lXHJcbiAgICogQHBhcmFtIHBhdGhcclxuICAgKi9cclxuICBwcml2YXRlIGhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxyXG4gICAgICBnZXRWYWx1ZSh0aGlzLl9pbml0aWFsU3RhdGUsIHBhdGgpICE9PSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xyXG4gIH1cclxufVxyXG4iXX0=