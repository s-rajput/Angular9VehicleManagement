/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, NgxsSimpleChange, SELECTOR_META_KEY } from '../symbols';
import { getValue } from '../utils/utils';
/**
 * @record
 * @template T, U
 */
export function StateClassInternal() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.makeRootSelector;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
}
/**
 * @record
 */
export function RuntimeSelectorContext() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getStateGetter = function (key) { };
    /**
     * @param {?=} localOptions
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getSelectorOptions = function (localOptions) { };
}
/**
 * @record
 */
export function SharedSelectorOptions() { }
if (false) {
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.injectContainerState;
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.suppressErrors;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.makeRootSelector;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
    /** @type {?} */
    SelectorMetaDataModel.prototype.getSelectorOptions;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.isInitialised;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.path;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * @record
 * @template T
 */
export function RootStateDiff() { }
if (false) {
    /** @type {?} */
    RootStateDiff.prototype.currentAppState;
    /** @type {?} */
    RootStateDiff.prototype.newAppState;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            /**
             * @param {?} context
             * @return {?}
             */
            makeRootSelector(context) {
                return context.getStateGetter(defaultMetadata.name);
            },
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            makeRootSelector: null,
            originalFn: null,
            containerClass: null,
            selectorName: null,
            getSelectorOptions: (/**
             * @return {?}
             */
            () => ({}))
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = paths.slice();
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/**
 * @template T
 * @param {?} mappedStore
 * @param {?} diff
 * @return {?}
 */
export function getStateDiffChanges(mappedStore, diff) {
    /** @type {?} */
    const previousValue = getValue(diff.currentAppState, mappedStore.path);
    /** @type {?} */
    const currentValue = getValue(diff.newAppState, mappedStore.path);
    return new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixnQkFBZ0IsRUFDaEIsaUJBQWlCLEVBRWxCLE1BQU0sWUFBWSxDQUFDO0FBRXBCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFHMUMsd0NBR0M7Ozs7Ozs7Ozs7O0FBS0QscUNBTUM7Ozs7O0lBTEMscURBQWM7Ozs7O0lBRWQsd0RBQW9COzs7OztJQUVwQiw0REFBaUQ7Ozs7O0FBR25ELG1DQU9DOzs7SUFOQyw2QkFBb0I7O0lBQ3BCLGdDQUFnRDs7SUFDaEQsaUNBQWM7O0lBQ2QsNkJBQW9COztJQUNwQix5Q0FBeUM7O0lBQ3pDLGlDQUFnQzs7Ozs7QUFHbEMsNENBR0M7Ozs7OztJQUZDLHFFQUE4Qzs7Ozs7SUFDOUMsa0ZBQWdGOzs7OztBQU1sRiwyQ0FHQzs7O0lBRkMscURBQStCOztJQUMvQiwrQ0FBeUI7Ozs7O0FBRzNCLDJDQU1DOzs7SUFMQyxpREFBeUM7O0lBQ3pDLDJDQUE0Qjs7SUFDNUIsK0NBQW9COztJQUNwQiw2Q0FBNEI7O0lBQzVCLG1EQUFnRDs7Ozs7QUFHbEQsaUNBT0M7OztJQU5DLDJCQUFhOztJQUNiLG9DQUF1Qjs7SUFDdkIsOEJBQWdEOztJQUNoRCwrQkFBYzs7SUFDZCwrQkFBYzs7SUFDZCwyQkFBYTs7Ozs7QUFHZix1Q0FHQzs7O0lBRkMscUNBQWM7O0lBQ2QsbUNBQXNCOzs7Ozs7QUFLeEIsbUNBR0M7OztJQUZDLHdDQUFtQjs7SUFDbkIsb0NBQWU7Ozs7Ozs7OztBQVFqQixNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBMEI7SUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7O2NBQzlCLGVB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QUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFVBQVUsQ0FBQztBQUNoRixDQUFDOzs7Ozs7O0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUNqQyxXQUF3QixFQUN4QixJQUFzQjs7VUFFaEIsYUFBYSxHQUFNLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUM7O1VBQ25FLFlBQVksR0FBTSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQ3BFLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbGFpbk9iamVjdE9mLCBTdGF0ZUNsYXNzIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBNRVRBX0tFWSxcclxuICBNRVRBX09QVElPTlNfS0VZLFxyXG4gIE5neHNDb25maWcsXHJcbiAgTmd4c1NpbXBsZUNoYW5nZSxcclxuICBTRUxFQ1RPUl9NRVRBX0tFWSxcclxuICBTdG9yZU9wdGlvbnNcclxufSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgQWN0aW9uSGFuZGxlck1ldGFEYXRhIH0gZnJvbSAnLi4vYWN0aW9ucy9zeW1ib2xzJztcclxuaW1wb3J0IHsgZ2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcblxyXG4vLyBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzY3NDM4OVxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3NJbnRlcm5hbDxUID0gYW55LCBVID0gYW55PiBleHRlbmRzIFN0YXRlQ2xhc3M8VD4ge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG4gIFtNRVRBX09QVElPTlNfS0VZXT86IFN0b3JlT3B0aW9uczxVPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVLZXlHcmFwaCA9IFBsYWluT2JqZWN0T2Y8c3RyaW5nW10+O1xyXG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgc2V0U3RhdGUodmFsOiBUKTogVDtcclxuXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFEYXRhTW9kZWwge1xyXG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XHJcbiAgYWN0aW9uczogUGxhaW5PYmplY3RPZjxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBwYXRoOiBzdHJpbmcgfCBudWxsO1xyXG4gIG1ha2VSb290U2VsZWN0b3I6IFNlbGVjdG9yRmFjdG9yeSB8IG51bGw7XHJcbiAgY2hpbGRyZW4/OiBTdGF0ZUNsYXNzSW50ZXJuYWxbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSdW50aW1lU2VsZWN0b3JDb250ZXh0IHtcclxuICBnZXRTdGF0ZUdldHRlcihrZXk6IGFueSk6IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcbiAgZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsT3B0aW9ucz86IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyk6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucztcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU2VsZWN0RnJvbVJvb3RTdGF0ZSA9IChyb290U3RhdGU6IGFueSkgPT4gYW55O1xyXG5leHBvcnQgdHlwZSBTZWxlY3RvckZhY3RvcnkgPSAocnVudGltZUNvbnRleHQ6IFJ1bnRpbWVTZWxlY3RvckNvbnRleHQpID0+IFNlbGVjdEZyb21Sb290U3RhdGU7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNoYXJlZFNlbGVjdG9yT3B0aW9ucyB7XHJcbiAgaW5qZWN0Q29udGFpbmVyU3RhdGU/OiBib29sZWFuO1xyXG4gIHN1cHByZXNzRXJyb3JzPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIG1ha2VSb290U2VsZWN0b3I6IFNlbGVjdG9yRmFjdG9yeSB8IG51bGw7XHJcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb24gfCBudWxsO1xyXG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XHJcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfCBudWxsO1xyXG4gIGdldFNlbGVjdG9yT3B0aW9uczogKCkgPT4gU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcHBlZFN0b3JlIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgaXNJbml0aWFsaXNlZDogYm9vbGVhbjtcclxuICBhY3Rpb25zOiBQbGFpbk9iamVjdE9mPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbiAgcGF0aDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlc0FuZERlZmF1bHRzIHtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHN0YXRlczogTWFwcGVkU3RvcmVbXTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQ2FsbGJhY2s8VCA9IGFueSwgViA9IGFueT4gPSAoLi4uYXJnczogVltdKSA9PiBUO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSb290U3RhdGVEaWZmPFQ+IHtcclxuICBjdXJyZW50QXBwU3RhdGU6IFQ7XHJcbiAgbmV3QXBwU3RhdGU6IFQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBjbGFzcyBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzSW50ZXJuYWwpOiBNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogTWV0YURhdGFNb2RlbCA9IHtcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgYWN0aW9uczoge30sXHJcbiAgICAgIGRlZmF1bHRzOiB7fSxcclxuICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgbWFrZVJvb3RTZWxlY3Rvcihjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0U3RhdGVHZXR0ZXIoZGVmYXVsdE1ldGFkYXRhLm5hbWUpO1xyXG4gICAgICB9LFxyXG4gICAgICBjaGlsZHJlbjogW11cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHN0YXRlIGNsYXNzIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzSW50ZXJuYWwpOiBNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXSE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBGdW5jdGlvbik6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoU0VMRUNUT1JfTUVUQV9LRVkpKSB7XHJcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCA9IHtcclxuICAgICAgbWFrZVJvb3RTZWxlY3RvcjogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbCxcclxuICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zOiAoKSA9PiAoe30pXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFNFTEVDVE9SX01FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IGFueSk6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogTm90ZTogVGhpcyBpcyBub3QgYXMgZmFzdCBhcyB0aGUgYGZhc3RQcm9wR2V0dGVyYCBidXQgaXMgc3RyaWN0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGNvbXBsaWFudC5cclxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBjb3B5T2ZQYXRocyA9IHBhdGhzLnNsaWNlKCk7XHJcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuOlxyXG4gKiAtIHBsdWNrIChPYnNlcnZhYmxlIG9wZXJhdG9yKVxyXG4gKiAtIG1lbW9pemVcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZmFzdFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhzO1xyXG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBsID0gc2VnbWVudHMubGVuZ3RoO1xyXG5cclxuICBsZXQgZXhwciA9IHNlZztcclxuICB3aGlsZSAoKytpIDwgbCkge1xyXG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XHJcblxyXG4gIHJldHVybiA8KHg6IGFueSkgPT4gYW55PmZuO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29tcGF0aWJpbGl0eSAmJiBjb25maWcuY29tcGF0aWJpbGl0eS5zdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3kpIHtcclxuICAgIHJldHVybiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhc3RQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxyXG4gKiAgICBjb25zdCBzdGF0ZXMgPSBbXHJcbiAqICAgICAgQ2FydCxcclxuICogICAgICBDYXJ0U2F2ZWQsXHJcbiAqICAgICAgQ2FydFNhdmVkSXRlbXNcclxuICogICAgXVxyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdyYXBoKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzZXMuZmluZChnID0+IGcgPT09IHN0YXRlQ2xhc3MpO1xyXG4gICAgaWYgKCFtZXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2hpbGQgc3RhdGUgbm90IGZvdW5kOiAke3N0YXRlQ2xhc3N9LiBcXHJcXG5Zb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGFkZCBzdGF0ZXMgdG8gbW9kdWxlYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtZXRhW01FVEFfS0VZXSEubmFtZSE7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oXHJcbiAgICAocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcclxuICAgICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG4gICAgICByZXN1bHRbbmFtZSFdID0gKGNoaWxkcmVuIHx8IFtdKS5tYXAoZmluZE5hbWUpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxyXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4ge1xyXG4gIHJldHVybiBzdGF0ZXMucmVkdWNlPFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPj4oXHJcbiAgICAocmVzdWx0OiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4sIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xyXG4gICAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG4gICAgICByZXN1bHRbbWV0YS5uYW1lIV0gPSBzdGF0ZUNsYXNzO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHIgPSB7XHJcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcclxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcclxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChcclxuICBvYmo6IFN0YXRlS2V5R3JhcGgsXHJcbiAgbmV3T2JqOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fVxyXG4pOiBQbGFpbk9iamVjdE9mPHN0cmluZz4ge1xyXG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGQpIHtcclxuICAgICAgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KGtleSkgJiYgY2hpbGRba2V5XS5pbmRleE9mKGtleVRvRmluZCkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcclxuICAgICAgbmV3T2JqW2tleV0gPSBwYXJlbnQgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByZXN1bHRzID0gW1xyXG4gKiAgICAnaXRlbXMnLFxyXG4gKiAgICAnc2F2ZWQnLFxyXG4gKiAgICAnY2FydCdcclxuICogIF07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XHJcbiAgY29uc3Qgc29ydGVkOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHZpc2l0ZWQ6IFBsYWluT2JqZWN0T2Y8Ym9vbGVhbj4gPSB7fTtcclxuXHJcbiAgY29uc3QgdmlzaXQgPSAobmFtZTogc3RyaW5nLCBhbmNlc3RvcnM6IHN0cmluZ1tdID0gW10pID0+IHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbmNlc3RvcnMpKSB7XHJcbiAgICAgIGFuY2VzdG9ycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGFuY2VzdG9ycy5wdXNoKG5hbWUpO1xyXG4gICAgdmlzaXRlZFtuYW1lXSA9IHRydWU7XHJcblxyXG4gICAgZ3JhcGhbbmFtZV0uZm9yRWFjaCgoZGVwOiBzdHJpbmcpID0+IHtcclxuICAgICAgaWYgKGFuY2VzdG9ycy5pbmRleE9mKGRlcCkgPj0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XHJcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xyXG5cclxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSkge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGVEaWZmQ2hhbmdlczxUPihcclxuICBtYXBwZWRTdG9yZTogTWFwcGVkU3RvcmUsXHJcbiAgZGlmZjogUm9vdFN0YXRlRGlmZjxUPlxyXG4pOiBOZ3hzU2ltcGxlQ2hhbmdlIHtcclxuICBjb25zdCBwcmV2aW91c1ZhbHVlOiBUID0gZ2V0VmFsdWUoZGlmZi5jdXJyZW50QXBwU3RhdGUsIG1hcHBlZFN0b3JlLnBhdGgpO1xyXG4gIGNvbnN0IGN1cnJlbnRWYWx1ZTogVCA9IGdldFZhbHVlKGRpZmYubmV3QXBwU3RhdGUsIG1hcHBlZFN0b3JlLnBhdGgpO1xyXG4gIHJldHVybiBuZXcgTmd4c1NpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsICFtYXBwZWRTdG9yZS5pc0luaXRpYWxpc2VkKTtcclxufVxyXG4iXX0=