/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _initialState
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const stateFactory = this;
            /** @type {?} */
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    /**
                     * @param {?} key
                     * @return {?}
                     */
                    getStateGetter(key) {
                        /** @type {?} */
                        const path = stateFactory.statePaths[key];
                        return path ? propGetter(path.split('.'), stateFactory._config) : (/**
                         * @return {?}
                         */
                        () => undefined);
                    },
                    /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    getSelectorOptions(localOptions) {
                        /** @type {?} */
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @return {?}
     */
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    static checkStatesAreValid(stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        StateFactory.checkStatesAreValid(stateClasses);
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const paths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const path = paths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, path);
            /** @type {?} */
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const mappedStores = this.add(classes);
        /** @type {?} */
        const defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        (result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults)), {});
        return { defaults, states: mappedStores };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ action }) => this.invokeActions(this._actions, (/** @type {?} */ (action))).pipe(map((/**
         * @return {?}
         */
        () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
        this._connected = true;
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLGtCQUFrQixFQUNsQixRQUFRLEVBR1IsV0FBVyxFQUNYLFVBQVUsRUFLVixlQUFlLEVBR2hCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUErQixlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLG1CQUFtQixFQUFpQixPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7Ozs7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RUFBRSxJQUFZO1FBQzVELElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQUEsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ25DLHFGQUFxRjtRQUNyRiw2RUFBNkU7UUFDN0UseUZBQXlGO1FBQ3pGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7Ozs7Ozs7Ozs7SUFTTyw2QkFBNkIsQ0FBQyxJQUFZLEVBQUUsSUFBWTs7Y0FDeEQsaUNBQWlDLEdBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxLQUFLLFNBQVM7UUFDbEQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLGlDQUFpQyxDQUFDO0lBQ3RFLENBQUM7OztZQS9PRixVQUFVOzs7O1lBekNVLFFBQVE7WUFZVixVQUFVO1lBc0NELFlBQVksdUJBRm5DLFFBQVEsWUFDUixRQUFRO1lBbEJ5QixlQUFlO1lBQzVDLCtCQUErQjtZQUMvQixtQkFBbUI7NENBcUJ2QixRQUFRLFlBQ1IsTUFBTSxTQUFDLG1CQUFtQjs7Ozs7OztJQVo3QixrQ0FBMkI7Ozs7O0lBZ0IzQiwrQkFBb0M7Ozs7O0lBTXBDLHFDQUF5Qzs7Ozs7SUFNekMsbUNBQWdEOztJQU1oRCxpREFrQkc7Ozs7O0lBakRELGlDQUEyQjs7Ozs7SUFDM0IsK0JBQTJCOzs7OztJQUMzQixzQ0FFb0M7Ozs7O0lBQ3BDLGdDQUFpQzs7Ozs7SUFDakMsc0NBQXVEOzs7OztJQUN2RCw0Q0FBaUQ7Ozs7O0lBQ2pELHFDQUUwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBPcHRpb25hbCwgU2tpcFNlbGYsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmb3JrSm9pbiwgZnJvbSwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtcclxuICBjYXRjaEVycm9yLFxyXG4gIGRlZmF1bHRJZkVtcHR5LFxyXG4gIGZpbHRlcixcclxuICBtYXAsXHJcbiAgbWVyZ2VNYXAsXHJcbiAgc2hhcmVSZXBsYXksXHJcbiAgdGFrZVVudGlsXHJcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHtcclxuICBidWlsZEdyYXBoLFxyXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcclxuICBpc09iamVjdCxcclxuICBNYXBwZWRTdG9yZSxcclxuICBNZXRhRGF0YU1vZGVsLFxyXG4gIG5hbWVUb1N0YXRlLFxyXG4gIHByb3BHZXR0ZXIsXHJcbiAgU3RhdGVDbGFzc0ludGVybmFsLFxyXG4gIFN0YXRlS2V5R3JhcGgsXHJcbiAgU3RhdGVzQW5kRGVmYXVsdHMsXHJcbiAgU3RhdGVzQnlOYW1lLFxyXG4gIHRvcG9sb2dpY2FsU29ydCxcclxuICBSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxyXG4gIFNoYXJlZFNlbGVjdG9yT3B0aW9uc1xyXG59IGZyb20gJy4vaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSwgZ2V0VmFsdWUsIHNldFZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcclxuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XHJcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMgfSBmcm9tICcuLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0b3JlVmFsaWRhdG9ycyB9IGZyb20gJy4uL3V0aWxzL3N0b3JlLXZhbGlkYXRvcnMnO1xyXG5pbXBvcnQgeyBJTklUSUFMX1NUQVRFX1RPS0VOLCBQbGFpbk9iamVjdE9mLCBtZW1vaXplIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSB7XHJcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KElOSVRJQUxfU1RBVEVfVE9LRU4pXHJcbiAgICBwcml2YXRlIF9pbml0aWFsU3RhdGU6IGFueVxyXG4gICkge31cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gIHB1YmxpYyBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XHJcblxyXG4gIHB1YmxpYyBnZXQgc3RhdGVzQnlOYW1lKCk6IFN0YXRlc0J5TmFtZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzQnlOYW1lIDogdGhpcy5fc3RhdGVzQnlOYW1lO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfc3RhdGVQYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0ge307XHJcblxyXG4gIHByaXZhdGUgZ2V0IHN0YXRlUGF0aHMoKTogUGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZVBhdGhzIDogdGhpcy5fc3RhdGVQYXRocztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0ID0gbWVtb2l6ZSgoKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZUZhY3RvcnkgPSB0aGlzO1xyXG4gICAgY29uc3QgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCA9IHRoaXMuX3BhcmVudEZhY3RvcnlcclxuICAgICAgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKVxyXG4gICAgICA6IHtcclxuICAgICAgICAgIGdldFN0YXRlR2V0dGVyKGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBzdGF0ZUZhY3Rvcnkuc3RhdGVQYXRoc1trZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aCA/IHByb3BHZXR0ZXIocGF0aC5zcGxpdCgnLicpLCBzdGF0ZUZhY3RvcnkuX2NvbmZpZykgOiAoKSA9PiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsT3B0aW9ucz86IFNoYXJlZFNlbGVjdG9yT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxTZWxlY3Rvck9wdGlvbnMgPSBzdGF0ZUZhY3RvcnkuX2NvbmZpZy5zZWxlY3Rvck9wdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4uZ2xvYmFsU2VsZWN0b3JPcHRpb25zLFxyXG4gICAgICAgICAgICAgIC4uLihsb2NhbE9wdGlvbnMgfHwge30pXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG4gIH0pO1xyXG5cclxuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZmF1bHRzKGRlZmF1bHRzOiBhbnkpOiBhbnkge1xyXG4gICAgbGV0IHZhbHVlID0ge307XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XHJcbiAgICAgIHZhbHVlID0gZGVmYXVsdHMuc2xpY2UoKTtcclxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XHJcbiAgICAgIHZhbHVlID0geyAuLi5kZWZhdWx0cyB9O1xyXG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0ge307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGNoZWNrU3RhdGVzQXJlVmFsaWQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IHZvaWQge1xyXG4gICAgc3RhdGVDbGFzc2VzLmZvckVhY2goU3RvcmVWYWxpZGF0b3JzLmdldFZhbGlkU3RhdGVNZXRhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXHJcbiAgICovXHJcbiAgYWRkKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIFN0YXRlRmFjdG9yeS5jaGVja1N0YXRlc0FyZVZhbGlkKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCB7IG5ld1N0YXRlcyB9ID0gdGhpcy5hZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgaWYgKCFuZXdTdGF0ZXMubGVuZ3RoKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3Qgc3RhdGVHcmFwaDogU3RhdGVLZXlHcmFwaCA9IGJ1aWxkR3JhcGgobmV3U3RhdGVzKTtcclxuICAgIGNvbnN0IHNvcnRlZFN0YXRlczogc3RyaW5nW10gPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBwYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoOiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4gPSBuYW1lVG9TdGF0ZShuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwgPSBuYW1lR3JhcGhbbmFtZV07XHJcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xyXG4gICAgICBjb25zdCBtZXRhOiBNZXRhRGF0YU1vZGVsID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG5cclxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBwYXRoKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlTWFwOiBNYXBwZWRTdG9yZSA9IHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgaXNJbml0aWFsaXNlZDogZmFsc2UsXHJcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxyXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLl9pbmplY3Rvci5nZXQoc3RhdGVDbGFzcyksXHJcbiAgICAgICAgZGVmYXVsdHM6IFN0YXRlRmFjdG9yeS5jbG9uZURlZmF1bHRzKG1ldGEuZGVmYXVsdHMpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcclxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcclxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXHJcbiAgICAgIGlmICghdGhpcy5oYXNCZWVuTW91bnRlZEFuZEJvb3RzdHJhcHBlZChuYW1lLCBwYXRoKSkge1xyXG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHRzXHJcbiAgICovXHJcbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcclxuICAgIGNvbnN0IGNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gc3RhdGVDbGFzc2VzIHx8IFtdO1xyXG5cclxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xyXG4gICAgY29uc3QgZGVmYXVsdHMgPSBtYXBwZWRTdG9yZXMucmVkdWNlKFxyXG4gICAgICAocmVzdWx0OiBhbnksIG1hcHBlZFN0b3JlOiBNYXBwZWRTdG9yZSkgPT5cclxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcclxuICAgICAge31cclxuICAgICk7XHJcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgdGhlIGFjdGlvbnMgdG8gdGhlIGhhbmRsZXJzXHJcbiAgICovXHJcbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xyXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy5fYWN0aW9uc1xyXG4gICAgICAucGlwZShcclxuICAgICAgICBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LnN0YXR1cyA9PT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICAgIG1lcmdlTWFwKCh7IGFjdGlvbiB9KSA9PlxyXG4gICAgICAgICAgdGhpcy5pbnZva2VBY3Rpb25zKHRoaXMuX2FjdGlvbnMsIGFjdGlvbiEpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxyXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+XHJcbiAgICAgICAgICAgICAgb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xyXG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlQWN0aW9ucyhhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBhY3Rpb246IGFueSkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uKSE7XHJcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChhY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoXHJcbiAgICBzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdXHJcbiAgKTogeyBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdIH0ge1xyXG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IFtdO1xyXG4gICAgY29uc3Qgc3RhdGVzTWFwOiBTdGF0ZXNCeU5hbWUgPSB0aGlzLnN0YXRlc0J5TmFtZTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlTmFtZTogc3RyaW5nID0gU3RvcmVWYWxpZGF0b3JzLmNoZWNrU3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcclxuICAgICAgY29uc3QgdW5tb3VudGVkU3RhdGUgPSAhc3RhdGVzTWFwW3N0YXRlTmFtZV07XHJcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xyXG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xyXG4gICAgICAgIHN0YXRlc01hcFtzdGF0ZU5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiBNZXRhRGF0YU1vZGVsLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMuc3RhdGVQYXRoc1ttZXRhLm5hbWUhXSA9IHBhdGg7XHJcbiAgICAvLyBUT0RPOiB2NCAtIHdlIHBsYW4gdG8gZ2V0IHJpZCBvZiB0aGUgcGF0aCBwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vbi1kZXRlcm1pbmlzdGljXHJcbiAgICAvLyB3ZSBjYW4gZG8gdGhpcyB3aGVuIHdlIGdldCByaWQgb2YgdGhlIGluY29ycmVjdGx5IGV4cG9zZWQgZ2V0U3RvcmVNZXRhZGF0YVxyXG4gICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhbiBhbHRlcm5hdGl2ZSBpbiB2NCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBieSBtYW55IHBsdWdpbnNcclxuICAgIG1ldGEucGF0aCA9IHBhdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiB0aGUgbWV0aG9kIGNoZWNrcyBpZiB0aGUgc3RhdGUgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgdHJlZVxyXG4gICAqIGFuZCBjb21wbGV0ZWQgdGhlIGxpZmUgY3ljbGVcclxuICAgKiBAcGFyYW0gbmFtZVxyXG4gICAqIEBwYXJhbSBwYXRoXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBoYXNCZWVuTW91bnRlZEFuZEJvb3RzdHJhcHBlZChuYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlOiBib29sZWFuID1cclxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzQnlOYW1lW25hbWVdICYmIHZhbHVlSXNCb290c3RyYXBwZWRJbkluaXRpYWxTdGF0ZTtcclxuICB9XHJcbn1cclxuIl19