{"version":3,"file":"ngxs-store-operators.js","sources":["ng:/@ngxs/store/operators/append.ts","ng:/@ngxs/store/operators/compose.ts","ng:/@ngxs/store/operators/utils.ts","ng:/@ngxs/store/operators/iif.ts","ng:/@ngxs/store/operators/insert-item.ts","ng:/@ngxs/store/operators/patch.ts","ng:/@ngxs/store/operators/update-item.ts","ng:/@ngxs/store/operators/remove-item.ts"],"names":[],"mappings":"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","sourcesContent":["import { StateOperator } from '@ngxs/store';\r\nimport { RepairType } from './utils';\r\n\r\n/**\r\n * @param items - Specific items to append to the end of an array\r\n */\r\nexport function append<T>(items: T[]): StateOperator<RepairType<T>[]> {\r\n  return function appendOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\r\n    // If `items` is `undefined` or `null` or `[]` but `existing` is provided\r\n    // just return `existing`\r\n    const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\r\n    if (itemsNotProvidedButExistingIs) {\r\n      return existing as RepairType<T>[];\r\n    }\r\n\r\n    if (Array.isArray(existing)) {\r\n      return existing.concat(items as RepairType<T>[]);\r\n    }\r\n\r\n    // For example if some property is added dynamically\r\n    // and didn't exist before thus it's not `ArrayLike`\r\n    return items as RepairType<T>[];\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\n\r\nexport function compose<T>(...operators: StateOperator<T>[]): StateOperator<T> {\r\n  return function composeOperator(existing: Readonly<T>): T {\r\n    return operators.reduce((accumulator, operator) => operator(accumulator), existing);\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\n\r\nimport { Predicate } from './internals';\r\n\r\nexport function isStateOperator<T>(value: T | StateOperator<T>): value is StateOperator<T> {\r\n  return typeof value === 'function';\r\n}\r\n\r\nexport function isUndefined(value: any): value is undefined {\r\n  return typeof value === 'undefined';\r\n}\r\n\r\nexport function isPredicate<T>(value: Predicate<T> | boolean | number): value is Predicate<T> {\r\n  return typeof value === 'function';\r\n}\r\n\r\nexport function isNumber(value: any): value is number {\r\n  return typeof value === 'number';\r\n}\r\n\r\nexport function invalidIndex(index: number): boolean {\r\n  return Number.isNaN(index) || index === -1;\r\n}\r\n\r\nexport function isNil<T>(value: T | null | undefined): value is null | undefined {\r\n  return value === null || isUndefined(value);\r\n}\r\n\r\nexport type RepairType<T> = T extends true ? boolean : (T extends false ? boolean : T);\r\n","import { StateOperator } from '@ngxs/store';\r\n\r\nimport { isStateOperator, isUndefined, isPredicate, RepairType } from './utils';\r\nimport { Predicate } from './internals';\r\n\r\nfunction retrieveValue<T>(\r\n  operatorOrValue: StateOperator<T> | T,\r\n  existing?: Readonly<RepairType<T>>\r\n): RepairType<T> {\r\n  // If state operator is a function\r\n  // then call it with an original value\r\n  if (isStateOperator(operatorOrValue)) {\r\n    const value = operatorOrValue(existing! as Readonly<T>);\r\n    return value as RepairType<T>;\r\n  }\r\n\r\n  // If operator or value was not provided\r\n  // e.g. `elseOperatorOrValue` is `undefined`\r\n  // then we just return an original value\r\n  if (isUndefined(operatorOrValue)) {\r\n    return (<any>existing)! as RepairType<T>;\r\n  }\r\n\r\n  return operatorOrValue as RepairType<T>;\r\n}\r\n\r\n/**\r\n * @param condition - Condition can be a plain boolean value or a function,\r\n * that returns boolean, also this function can take a value as an argument\r\n * to which this state operator applies\r\n * @param trueOperatorOrValue - Any value or a state operator\r\n * @param elseOperatorOrValue - Any value or a state operator\r\n */\r\nexport function iif<T>(\r\n  condition: Predicate<T> | boolean,\r\n  trueOperatorOrValue: StateOperator<T> | T,\r\n  elseOperatorOrValue?: StateOperator<T> | T\r\n): StateOperator<RepairType<T>> {\r\n  return function iifOperator(existing: Readonly<RepairType<T>>): RepairType<T> {\r\n    // Convert the value to a boolean\r\n    let result = !!condition;\r\n    // but if it is a function then run it to get the result\r\n    if (isPredicate(condition)) {\r\n      result = condition(existing);\r\n    }\r\n\r\n    if (result) {\r\n      return retrieveValue<T>(trueOperatorOrValue, existing as RepairType<T>);\r\n    }\r\n\r\n    return retrieveValue<T>(elseOperatorOrValue!, existing as RepairType<T>);\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\nimport { isNil, RepairType } from './utils';\r\n\r\n/**\r\n * @param value - Value to insert\r\n * @param [beforePosition] -  Specified index to insert value before, optional\r\n */\r\nexport function insertItem<T>(\r\n  value: T,\r\n  beforePosition?: number\r\n): StateOperator<RepairType<T>[]> {\r\n  return function insertItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\r\n    // Have to check explicitly for `null` and `undefined`\r\n    // because `value` can be `0`, thus `!value` will return `true`\r\n    if (isNil(value) && existing) {\r\n      return existing as RepairType<T>[];\r\n    }\r\n\r\n    // Property may be dynamic and might not existed before\r\n    if (!Array.isArray(existing)) {\r\n      return [value as RepairType<T>];\r\n    }\r\n\r\n    const clone = existing.slice();\r\n\r\n    let index = 0;\r\n\r\n    // No need to call `isNumber`\r\n    // as we are checking `> 0` not `>= 0`\r\n    // everything except number will return false here\r\n    if (beforePosition! > 0) {\r\n      index = beforePosition!;\r\n    }\r\n\r\n    clone.splice(index, 0, value as RepairType<T>);\r\n    return clone;\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\nimport { isStateOperator } from './utils';\r\n\r\nexport type PatchSpec<T> = { [P in keyof T]?: T[P] | StateOperator<NonNullable<T[P]>> };\r\n\r\ntype PatchValues<T> = {\r\n  readonly [P in keyof T]?: T[P] extends (...args: any[]) => infer R ? R : T[P];\r\n};\r\n\r\ntype PatchOperator<T> = <U extends PatchValues<T>>(existing: Readonly<U>) => U;\r\n\r\nexport function patch<T>(patchObject: PatchSpec<T>): PatchOperator<T> {\r\n  return function patchStateOperator<U extends PatchValues<T>>(existing: Readonly<U>): U {\r\n    let clone = null;\r\n    for (const k in patchObject) {\r\n      const newValue = patchObject[k];\r\n      const existingPropValue = existing[k];\r\n      const newPropValue = isStateOperator(newValue)\r\n        ? newValue(<any>existingPropValue)\r\n        : newValue;\r\n      if (newPropValue !== existingPropValue) {\r\n        if (!clone) {\r\n          clone = { ...(<any>existing) };\r\n        }\r\n        clone[k] = newPropValue;\r\n      }\r\n    }\r\n    return clone || existing;\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\n\r\nimport { isStateOperator, isPredicate, isNumber, invalidIndex, RepairType } from './utils';\r\nimport { Predicate } from './internals';\r\n\r\n/**\r\n * @param selector - Index of item in the array or a predicate function\r\n * that can be provided in `Array.prototype.findIndex`\r\n * @param operatorOrValue - New value under the `selector` index or a\r\n * function that can be applied to an existing value\r\n */\r\nexport function updateItem<T>(\r\n  selector: number | Predicate<T>,\r\n  operatorOrValue: T | StateOperator<T>\r\n): StateOperator<RepairType<T>[]> {\r\n  return function updateItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\r\n    let index = -1;\r\n\r\n    if (isPredicate(selector)) {\r\n      index = existing.findIndex(selector);\r\n    } else if (isNumber(selector)) {\r\n      index = selector;\r\n    }\r\n\r\n    if (invalidIndex(index)) {\r\n      return existing as RepairType<T>[];\r\n    }\r\n\r\n    let value: T = null!;\r\n    // Need to check if the new item value will change the existing item value\r\n    // then, only if it will change it then clone the array and set the item\r\n    if (isStateOperator(operatorOrValue)) {\r\n      value = operatorOrValue(existing[index] as Readonly<T>);\r\n    } else {\r\n      value = operatorOrValue;\r\n    }\r\n\r\n    // If the value hasn't been mutated\r\n    // then we just return `existing` array\r\n    if (value === existing[index]) {\r\n      return existing as RepairType<T>[];\r\n    }\r\n\r\n    const clone = existing.slice();\r\n    clone[index] = value as RepairType<T>;\r\n    return clone;\r\n  };\r\n}\r\n","import { StateOperator } from '@ngxs/store';\r\nimport { Predicate } from './internals';\r\nimport { isPredicate, isNumber, invalidIndex, RepairType } from './utils';\r\n\r\n/**\r\n * @param selector - index or predicate to remove an item from an array by\r\n */\r\nexport function removeItem<T>(\r\n  selector: number | Predicate<T>\r\n): StateOperator<RepairType<T>[]> {\r\n  return function removeItemOperator(existing: Readonly<RepairType<T>[]>): RepairType<T>[] {\r\n    let index = -1;\r\n\r\n    if (isPredicate(selector)) {\r\n      index = existing.findIndex(selector);\r\n    } else if (isNumber(selector)) {\r\n      index = selector;\r\n    }\r\n\r\n    if (invalidIndex(index)) {\r\n      return existing as RepairType<T>[];\r\n    }\r\n\r\n    const clone = existing.slice();\r\n    clone.splice(index, 1);\r\n    return clone;\r\n  };\r\n}\r\n"]}